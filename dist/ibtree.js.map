{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 62e052541210e27598bb","webpack:///./src/index.js","webpack:///./src/binarysearch.js","webpack:///./src/nodes.js","webpack:///./src/constants.js","webpack:///./src/utils.js","webpack:///./src/path.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;SCQgB,S,GAAA,S;SAooBA,K,GAAA,K;;AAlrBhB;;;;AACA;;AACA;;;;AACA;;AAYA;;;;;;AAWA,KAAM,YAAY,uBAAa,EAA/B;;AAEA,KAAM,YAAY,EAAlB;;AAGO,KAAM,gDAAoB,SAApB,iBAAoB,CAAC,CAAD,EAAI,CAAJ;AAAA,Y;AAC7B,eAAM,C;AAAN,WACM,CADN,GAEM,IAAI,CAAJ,GACI,CAAC,CADL,GAEI;AALmB;AAAA,EAA1B;;;;AAUP,KAAM,eAAe,SAAf,YAAe,CAAC,IAAD,EAAO,GAAP;AAAA,YAAe,KAAK,QAAL,CAAc,GAAd,CAAf;AAAA,EAArB;AACA,KAAM,aAAa,SAAb,UAAa,CAAC,IAAD,EAAO,GAAP;AAAA,YAAe,KAAK,IAAL,CAAU,GAAV,CAAf;AAAA,EAAnB;AACA,KAAM,eAAe,SAAf,YAAe,CAAC,IAAD,EAAO,GAAP;AAAA,YAAe,CAAC,WAAW,IAAX,EAAiB,GAAjB,CAAD,EAAwB,aAAa,IAAb,EAAmB,GAAnB,CAAxB,CAAf;AAAA,EAArB;;AAGO,UAAS,SAAT,CAAmB,KAAnB,EAA0B;AAC7B,SAAM,OAAO,SAAS,EAAtB;AACA,UAAK,KAAL;;;;AAIA,UAAK,KAAL,GAAa,KAAK,KAAL,KAAe,SAAf,GAA2B,KAA3B,GAAmC,KAAK,KAArD;;AAEA,UAAK,SAAL,GAAiB,KAAK,SAAtB,C;AACA,UAAK,UAAL,GAAkB,KAAK,UAAL,IAAmB,iBAArC;;AAEA,UAAK,IAAL,GAAY,KAAK,IAAL,IAAa,gBAAS,EAAE,OAAO,KAAK,KAAd,EAAT,CAAzB;AACA,UAAK,IAAL,GAAY,KAAK,IAAL,IAAa,CAAzB;AACA,UAAK,MAAL,GAAc,KAAK,MAAL,IAAe,CAA7B;AACA,UAAK,OAAL,GAAe,KAAK,OAApB;AACH;;AAED,oBAAO,UAAU,SAAjB,EAA4B;AACxB,QADwB,eACpB,GADoB,EACf;AACL,gBAAO,KAAK,MAAL,CAAY,KAAK,UAAjB,EAA6B,GAA7B,MAAsC,SAA7C;AACH,MAHuB;AAKxB,QALwB,eAKpB,KALoB,EAKb;AACP,gBAAO,KAAK,GAAL,CAAS,KAAT,EAAgB,KAAhB,CAAP;AACH,MAPuB;AASxB,QATwB,eASpB,GAToB,EASf;AACL,aAAM,MAAM,KAAK,MAAL,CAAY,KAAK,UAAjB,EAA6B,GAA7B,CAAZ;AACA,gBAAO,QAAQ,SAAR,GACD,SADC,GAED,GAFN;AAGH,MAduB;AAgBxB,UAhBwB,mBAgBhB;AACJ,gBAAO,IAAI,KAAK,WAAT,CAAqB;AACxB,yBAAY,KAAK,UADO;AAExB,wBAAW,KAAK;AAFQ,UAArB,CAAP;AAIH,MArBuB;AAuBxB,QAvBwB,eAuBpB,GAvBoB,EAuBf,KAvBe,EAuBR;AACZ,aAAM,MAAM,KAAK,UAAjB;AACA,aAAM,eAAe,KAAK,SAAL,GACf,KAAK,SAAL,CAAe,GAAf,CADe,GAEf,GAFN;;AAIA,aAAM,YAAY,oBAAQ,KAAR,CAAlB;AACA,aAAM,SAAS,KAAK,IAAL,CAAU,MAAV,CAAiB,GAAjB,EAAsB,KAAK,OAA3B,EAAoC,SAApC,EAA+C,YAA/C,EAA6D,KAA7D,CAAf;;AAEA,aAAI,CAAC,kBAAM,SAAN,CAAL,EAAuB,OAAO,IAAP;;AAEvB,aAAI,gBAAJ;AACA,aAAI,YAAY,KAAhB;AACA,aAAM,YAAY,CAAC,CAAC,KAAK,OAAzB;;;AAGA,aAAI,OAAO,MAAP,KAAkB,CAAtB,EAAyB;AACrB,yBAAY,IAAZ;AACA,iBAAM,WAAW,MAAjB;AACA,iBAAM,YAAY,SAAS,CAAT,CAAlB;AACA,iBAAM,aAAa,SAAS,CAAT,CAAnB;AACA,iBAAM,WAAW,SAAS,CAAT,CAAjB;;AAEA,iBAAM,cAAc,uBAAW,CAAC,SAAD,CAAX,EAAwB,KAAK,OAA7B,CAApB;AACA,iBAAM,kBAAkB,uBAAW,CAAC,UAAD,EAAa,QAAb,CAAX,EAAmC,KAAK,OAAxC,CAAxB;;AAEA,uBAAU,wBAAiB;AACvB,wBAAO,KAAK,KADW;AAEvB,uBAAM,WAFiB;AAGvB,2BAAU;AAHa,cAAjB,CAAV;AAKH,UAfD,MAeO;AACH,uBAAU,MAAV;AACH;;AAED,aAAM,YAAY,YAAY,KAAK,MAAL,GAAc,CAA1B,GAA8B,KAAK,MAArD;AACA,aAAM,UAAU,KAAK,IAAL,GAAY,CAA5B;;AAEA,aAAI,SAAJ,EAAe;AACX,kBAAK,MAAL,GAAc,SAAd;AACA,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,SAAL,GAAiB,IAAjB;AACA,oBAAO,IAAP;AACH;AACD,gBAAO,IAAI,KAAK,WAAT,CAAqB;AACxB,wBAAW,KAAK,SADQ;AAExB,yBAAY,KAAK,UAFO;AAGxB,mBAAM,OAHkB;AAIxB,qBAAQ,SAJgB;AAKxB,mBAAM,OALkB;AAMxB,sBAAS,KAAK;AANU,UAArB,CAAP;AAQH,MA5EuB;AA8ExB,WA9EwB,mBA8EjB,GA9EiB,EA8EZ;AACR,aAAM,YAAY,oBAAQ,KAAR,CAAlB;AACA,aAAI,UAAU,KAAK,IAAL,CAAU,MAAV,CACV,KAAK,UADK,EAEV,KAAK,OAFK,EAGV,SAHU,EAIV,GAJU,CAAd;;AAOA,aAAI,CAAC,kBAAM,SAAN,CAAL,EAAuB,OAAO,IAAP;;AAEvB,aAAI,aAAa,KAAjB;AACA,aAAI,QAAQ,IAAR,+BAAJ,EAAsC;AAClC,iBAAM,SAAS,QAAQ,WAAR,gBAAf;AACA,iBAAI,CAAC,MAAL,EAAa;;;;AAIT,2BAAU,QAAQ,QAAR,CAAiB,CAAjB,CAAV;AACA,8BAAa,IAAb;AACH;;AAEJ;;AAED,aAAM,YAAY,CAAC,CAAC,KAAK,OAAzB;;AAEA,aAAI,gBAAJ;AACA,aAAM,YAAY,aAAa,KAAK,MAAL,GAAc,CAA3B,GAA+B,KAAK,MAAtD;AACA,aAAM,UAAU,KAAK,IAAL,GAAY,CAA5B;;AAEA,aAAI,SAAJ,EAAe;AACX,uBAAU,IAAV;AACA,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,MAAL,GAAc,SAAd;AACA,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,SAAL,GAAiB,IAAjB;AACH,UAND,MAMO;AACH,uBAAU,IAAI,KAAK,WAAT,CAAqB;AAC3B,6BAAY,KAAK,UADU;AAE3B,4BAAW,KAAK,SAFW;AAG3B,uBAAM,OAHqB;AAI3B,yBAAQ,SAJmB;AAK3B,uBAAM,OALqB;AAM3B,0BAAS,KAAK;AANa,cAArB,CAAV;AAQH;AACD,gBAAO,OAAP;AACH,MA7HuB;AA+HxB,cA/HwB,uBA+HZ;AACR,gBAAO,KAAK,OAAL,GACD,IADC,GAED,IAAI,KAAK,WAAT,CAAqB;AACnB,yBAAY,KAAK,UADE;AAEnB,wBAAW,KAAK,SAFG;AAGnB,mBAAM,KAAK,IAHQ;AAInB,qBAAQ,KAAK,MAJM;AAKnB,mBAAM,KAAK,IALQ;AAMnB,sBAAS;AANU,UAArB,CAFN;AAUH,MA1IuB;AA4IxB,gBA5IwB,yBA4IV;AACV,gBAAO,KAAK,OAAL,GACD,IAAI,KAAK,WAAT,CAAqB;AACnB,yBAAY,KAAK,UADE;AAEnB,wBAAW,KAAK,SAFG;AAGnB,mBAAM,KAAK,IAHQ;AAInB,qBAAQ,KAAK,MAJM;AAKnB,mBAAM,KAAK;AALQ,UAArB,CADC,GAQD,IARN;AASH,MAtJuB;AAwJxB,kBAxJwB,yBAwJV,EAxJU,EAwJN;AACd,aAAM,UAAU,KAAK,SAAL,EAAhB;AACA,YAAG,OAAH;AACA,gBAAO,QAAQ,SAAR,GAAoB,QAAQ,WAAR,EAApB,GAA4C,IAAnD;AACH,MA5JuB;AA8JxB,iBA9JwB,wBA8JX,SA9JW,EA8JA,UA9JA,EA8JY;AAChC,aAAI,KAAK,IAAL,KAAc,CAAlB,EAAqB,OAAO,8BAAP;;AAErB,aAAM,YAAY,+BAAmB,UAAnB,CAAlB;;AAEA,aAAM,UAAU,KAAK,SAAL,GACV,KAAK,SAAL,CAAe,UAAU,IAAzB,CADU,GAEV,UAAU,IAFhB;;AAIA,aAAM,QAAQ,KAAK,SAAL,GACR,KAAK,SAAL,CAAe,UAAU,EAAzB,CADQ,GAER,UAAU,EAFhB;;AAIA,aAAM,YAAY,KAAK,UAAL,CAAgB,OAAhB,EAAyB,KAAzB,IAAkC,CAApD;;AAEA,aAAM,cAAc,SAApB;AACA,aAAM,YAAY,CAAC,WAAnB;;AAEA,aAAM,WAAW,KAAK,QAAL,CAAc,OAAd,EAAuB,WAAvB,EAAoC,UAAU,aAA9C,CAAjB;AACA,aAAM,SAAS,KAAK,QAAL,CAAc,KAAd,EAAqB,SAArB,EAAgC,UAAU,WAA1C,CAAf;;AAEA,aAAI,aAAa,IAAb,IAAqB,WAAW,IAApC,EAA0C;AACtC,oBAAO,8BAAP;AACH;;AAED,gBAAO,KAAK,eAAL,CACH,SADG,EAEH,QAFG,EAGH,MAHG,EAIH,SAJG,CAAP;AAMH,MA7LuB;AA+LxB,YA/LwB,mBA+LhB,OA/LgB,EA+LP,KA/LO,EA+LA;AACpB,aAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AACxB,iBAAM,YAAY,UAAU,CAAV,CAAlB;AACA,oBAAO,KAAK,YAAL,CAAkB,YAAlB,EAAgC,SAAhC,CAAP;AACH;;AAED,aAAM,OAAO;AACT,mBAAM,OADG;AAET,iBAAI;AAFK,UAAb;;AAKA,gBAAO,KAAK,YAAL,CAAkB,YAAlB,EAAgC,IAAhC,CAAP;AACH,MA3MuB;;;;;;;;;;AAoNxB,eApNwB,sBAoNb,IApNa,EAoNP;AACb,aAAM,QAAQ,IAAI,KAAJ,CAAU,KAAK,MAAf,CAAd;;AAEA,aAAI,OAAO,KAAK,IAAhB;AACA,cAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,mBAAM,CAAN,IAAW,IAAX;AACA,oBAAO,KAAK,QAAL,CAAc,KAAK,GAAL,CAAS,CAAT,CAAd,CAAP;AACH;;AAED,gBAAO,KAAP;AACH,MA9NuB;AAgOxB,cAhOwB,qBAgOd,IAhOc,EAgOR;AACZ,aAAM,QAAQ,KAAK,UAAL,CAAgB,IAAhB,CAAd;AACA,aAAI,QAAQ,MAAM,MAAN,GAAe,CAA3B;;;AAGA,aAAI,KAAK,GAAL,CAAS,KAAT,IAAkB,MAAM,KAAN,EAAa,QAAb,CAAsB,MAAtB,GAA+B,CAArD,EAAwD;AACpD,oBAAO,KAAK,SAAL,CAAe,KAAf,CAAP;AACH;;AAED;;;AAGA,gBAAO,SAAS,CAAT,IAAc,KAAK,GAAL,CAAS,KAAT,MAAoB,MAAM,KAAN,EAAa,QAAb,CAAsB,MAAtB,GAA+B,CAAxE;AAA2E;AAA3E,U;AAEA,aAAI,QAAQ,CAAZ,EAAe,OAAO,IAAP;AACf,gBAAO,KAAK,SAAL,CAAe,KAAf,CAAP;AACH,MAhPuB;AAkPxB,cAlPwB,qBAkPd,IAlPc,EAkPR;;AAEZ,aAAI,KAAK,MAAL,CAAY,eAAK,UAAjB,CAAJ,EAAkC,OAAO,IAAP;;AAElC,aAAM,QAAQ,KAAK,UAAL,CAAgB,IAAhB,CAAd;;AAEA,aAAI,QAAQ,KAAK,MAAL,GAAc,CAA1B;AACA,gBAAO,KAAK,GAAL,CAAS,KAAT,MAAoB,CAA3B;AAA8B;AAA9B,UAEA,IAAI,UAAU,KAAK,GAAL,CAAS,KAAT,EAAgB,KAAK,GAAL,CAAS,KAAT,IAAkB,CAAlC,CAAd;;;;AAIA,aAAI,OAAO,MAAM,KAAN,EAAa,QAAb,CAAsB,QAAQ,GAAR,CAAY,KAAZ,CAAtB,CAAX;AACA;AACA,gBAAO,QAAQ,KAAK,MAApB,EAA4B,OAA5B,EAAqC;AACjC,iBAAM,WAAW,KAAK,QAAL,CAAc,MAA/B;AACA,uBAAU,QAAQ,GAAR,CAAY,KAAZ,EAAmB,WAAW,CAA9B,CAAV;AACA,oBAAO,KAAK,QAAL,CAAc,WAAW,CAAzB,CAAP;AACH;AACD,gBAAO,OAAP;AACH,MAvQuB;AAyQxB,6BAzQwB,oCAyQC,SAzQD,EAyQY;AAChC,aAAI,KAAK,IAAL,KAAc,CAAlB,EAAqB,OAAO,8BAAP;;AAErB,gBAAO,KAAK,eAAL,CACH,SADG,EAEH,KAAK,gBAAL,EAFG,EAGH,KAAK,iBAAL,EAHG,CAAP;AAKH,MAjRuB;AAmRxB,qBAnRwB,4BAmRP,IAnRO,EAmRD;AACnB,aAAM,QAAQ,KAAK,MAAnB;;AAEA,aAAI,YAAY,CAAhB;AACA,aAAI,WAAW,KAAK,IAApB;;AAEA,gBAAO,cAAc,KAArB,EAA4B;AACxB,wBAAW,SAAS,QAAT,CAAkB,KAAK,GAAL,CAAS,WAAT,CAAlB,CAAX;AACH;AACD,gBAAO,QAAP;AACH,MA7RuB;AA+RxB,sBA/RwB,+BA+RJ;AAChB,aAAI,KAAK,IAAL,KAAc,CAAlB,EAAqB,OAAO,IAAP;;AAErB,aAAM,UAAU,EAAhB;AACA,aAAI,OAAO,KAAK,IAAhB;AACA,aAAI,YAAY,CAAhB;AACA,aAAM,YAAY,KAAK,MAAvB;;AAEA,gBAAO,cAAc,YAAY,CAAjC,EAAoC;AAChC,iBAAM,MAAM,KAAK,QAAL,CAAc,MAAd,GAAuB,CAAnC;AACA,qBAAQ,IAAR,CAAa,GAAb;AACA,oBAAO,KAAK,QAAL,CAAc,GAAd,CAAP;AACA;AACH;AACD,gBAAO,eAAK,IAAL,CAAU,OAAV,CAAP;AACH,MA9SuB;AAgTxB,qBAhTwB,8BAgTL;AACf,aAAI,KAAK,IAAL,KAAc,CAAlB,EAAqB;AACjB,oBAAO,IAAP;AACH;;AAED,gBAAO,yCAAoB,KAAK,MAAL,GAAc,CAAlC,CAAP;AACH,MAtTuB;AAwTxB,oBAxTwB,2BAwTR,SAxTQ,EAwTG,QAxTH,EAwTa,MAxTb,EAwTqB,SAxTrB,EAwTgC;AAAA;;AACpD,aAAM,mBAAmB,YACnB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CADmB,GAEnB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAFN;;AAIA,aAAM,YAAY,KAAK,MAAvB;;AAEA,aAAI,WAAW,QAAf;;;;;;AAMA,aAAI,qBAAJ;AACA,aAAI,OAAO,KAAX;AACA,aAAM,WAAW;AACb,mBAAM,gBAAM;AACR,qBAAM,UAAU,aAAa,IAAb,IAAqB,SAAS,MAAT,CAAgB,MAAhB,CAArC;AACA,qBAAI,aAAa,IAAb,KAAsB,CAAC,OAAD,IAAY,CAAC,IAAnC,CAAJ,EAA8C;AAC1C,yBAAM,SAAS,SAAS,GAAT,CAAa,SAAb,CAAf;AACA,yBAAM,OAAO,gBAAgB,MAAK,gBAAL,CAAsB,QAAtB,CAA7B;AACA,yBAAI,CAAC,OAAL,EAAc;AACV,6BAAI,aAAa,SAAS,CAA1B,EAA6B;;AAEzB,wCAAW,SAAS,SAAT,CAAmB,SAAnB,CAAX;AACH,0BAHD,MAGO,IAAI,CAAC,SAAD,IAAc,SAAS,KAAK,QAAL,CAAc,MAAd,GAAuB,CAAlD,EAAqD;;AAExD,wCAAW,SAAS,SAAT,CAAmB,SAAnB,CAAX;AACH,0BAHM,MAGA;AACH,wCAAW,iBAAiB,QAAjB,CAAX;AACA,4CAAe,SAAf;AACH;AACJ,sBAXD,MAWO;AACH,gCAAO,IAAP;AACH;;AAED,yBAAM,QAAQ,UAAU,IAAV,EAAgB,MAAhB,CAAd;;AAEA,4BAAO;AACH;AADG,sBAAP;AAGH;;AAED,wBAAO;AACH,2BAAM;AADH,kBAAP;AAGH;AA/BY,UAAjB;;AAkCA,kDAA8B;AAAA,oBAAM,QAAN;AAAA,UAA9B;;AAEA,gBAAO,QAAP;AACH,MA5WuB;AA8WxB,aA9WwB,oBA8Wf,GA9We,EA8WV,SA9WU,EA8WC,WA9WD,EA8Wc;AAClC,aAAI,KAAK,IAAL,KAAc,CAAlB,EAAqB,OAAO,IAAP;;AAErB,aAAM,MAAM,KAAK,UAAjB;;AAEA,aAAI,OAAO,KAAK,IAAhB;AACA,aAAM,yBAAyB,KAAK,MAApC;;;AAGA,aAAM,UAAU,IAAI,KAAJ,CAAU,yBAAyB,CAAnC,CAAhB;;AAEA,aAAI,IAAI,CAAR;AACA,aAAI,OAAO,IAAX;AACA,gBAAO,IAAI,sBAAX,EAAmC,GAAnC,EAAwC;AACpC,iBAAM,OAAM,KAAK,cAAL,CAAoB,GAApB,EAAyB,GAAzB,CAAZ;AACA,qBAAQ,CAAR,IAAa,IAAb;AACA,oBAAO,IAAP;AACA,oBAAO,KAAK,QAAL,CAAc,IAAd,CAAP;AACH;;AAED,aAAM,SAAS,IAAf;;AAEA,aAAM,iBAAiB,CAAC,YAAY,IAAZ,GAAmB,IAApB,KAA6B,cAAc,GAAd,GAAoB,EAAjD,CAAvB;AACA,aAAM,aAAa,uBAAa,cAAb,CAAnB;;;AAGA,aAAM,MAAM,WAAW,KAAK,IAAhB,EAAsB,GAAtB,EAA2B,GAA3B,CAAZ;;AAEA,aAAI,QAAQ,KAAK,IAAL,CAAU,MAAtB,EAA8B;AAC1B,iBAAI,CAAC,SAAL,EAAgB;;AAEZ,yBAAQ,IAAI,CAAZ;;AAEA,qBAAM,eAAe,QAAQ,IAAI,CAAZ,IAAiB,OAAO,QAAP,CAAgB,MAAtD;AACA,qBAAI,CAAC,YAAL,EAAmB,OAAO,IAAP;AACnB,wBAAO,OAAO,QAAP,CAAgB,QAAQ,IAAI,CAAZ,CAAhB,CAAP;AACA,qBAAI,KAAK,IAAL,CAAU,CAAV,KAAgB,GAApB,EAAyB;AACrB,6BAAQ,CAAR,IAAa,CAAb;AACH,kBAFD,MAEO;;AAEH,4BAAO,IAAP;AACH;AACJ,cAbD,MAaO;AACH,yBAAQ,CAAR,IAAa,MAAM,CAAnB;AACH;AACJ,UAjBD,MAiBO,IAAI,QAAQ,CAAC,CAAb,EAAgB;AACnB,iBAAI,SAAJ,EAAe;;AAEX,yBAAQ,IAAI,CAAZ;;AAEA,qBAAM,cAAc,QAAQ,IAAI,CAAZ,KAAkB,CAAtC;AACA,qBAAI,CAAC,WAAL,EAAkB,OAAO,IAAP;;AAElB,wBAAO,OAAO,QAAP,CAAgB,QAAQ,IAAI,CAAZ,CAAhB,CAAP;AACA,qBAAI,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,KAAmC,GAAvC,EAA4C;AACxC,6BAAQ,CAAR,IAAa,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAhC;AACH,kBAFD,MAEO;;AAEH,4BAAO,IAAP;AACH;AACJ,cAdD,MAcO;AACH,yBAAQ,CAAR,IAAa,CAAb;AACH;AACJ,UAlBM,MAkBA;AACH,qBAAQ,CAAR,IAAa,GAAb;AACH;;AAED,gBAAO,eAAK,IAAL,CAAU,OAAV,CAAP;AACH,MAlbuB;AAobxB,aApbwB,oBAobf,GApbe,EAobV,GApbU,EAobL;AACf,aAAI,OAAO,KAAK,IAAhB;AACA,aAAM,yBAAyB,KAAK,MAApC;AACA,cAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,sBAApB,EAA4C,GAA5C,EAAiD;AAC7C,iBAAM,MAAM,KAAK,cAAL,CAAoB,GAApB,EAAyB,GAAzB,CAAZ;AACA,oBAAO,KAAK,QAAL,CAAc,GAAd,CAAP;AACH;;AAED,gBAAO,IAAP;AACH,MA7buB;AA+bxB,WA/bwB,kBA+bjB,GA/biB,EA+bZ,GA/bY,EA+bP;AACb,aAAM,eAAe,KAAK,SAAL,GACf,KAAK,SAAL,CAAe,GAAf,CADe,GAEf,GAFN;;AAIA,aAAM,OAAO,KAAK,QAAL,CAAc,GAAd,EAAmB,YAAnB,CAAb;AACA,aAAM,MAAM,UAAU,KAAK,IAAf,EAAqB,YAArB,EAAmC,GAAnC,CAAZ;AACA,aAAI,QAAQ,CAAC,CAAb,EAAgB;AACZ,oBAAO,SAAP;AACH;;AAED,gBAAO,KAAK,QAAL,CAAc,GAAd,CAAP;AACH,MA3cuB;AA6cxB,UA7cwB,iBA6clB,EA7ckB,EA6cd;AACN,aAAM,QAAQ,CAAC,KAAK,IAAN,CAAd;AACA,gBAAO,MAAM,MAAb,EAAqB;AACjB,iBAAM,OAAO,MAAM,KAAN,EAAb;AACA,gBAAG,IAAH;AACA,iBAAI,KAAK,WAAL,oBAA6B,KAAK,QAAtC,EAAgD;AAC5C,uBAAM,IAAN,iCAAc,KAAK,QAAnB;AACH;AACJ;AACJ;AAtduB,EAA5B;;AAydA,KAAM,qBAAqB,SAArB,kBAAqB;AAAA,YACvB,SAAS,gBAAT,GAA4B;AACxB,aAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AACxB,oBAAO,KAAK,wBAAL,CAA8B,SAA9B,CAAP;AACH,UAFD,MAEO,IAAI,UAAU,MAAV,KAAqB,CAAzB,EAA4B;AAC/B,iBAAM,QAAO,UAAU,CAAV,CAAb;AACA,kBAAK,YAAL,CACI,SADJ,EAEI,KAFJ;AAIH;;AAED,aAAM,OAAO;AACT,mBAAM,UAAU,CAAV,CADG;AAET,iBAAI,UAAU,CAAV;AAFK,UAAb;;AAKA,gBAAO,KAAK,YAAL,CAAkB,SAAlB,EAA6B,IAA7B,CAAP;AACH,MAlBsB;AAAA,EAA3B;;AAqBA,WAAU,SAAV,CAAoB,MAApB,GAA6B,mBAAmB,YAAnB,CAA7B;AACA,WAAU,SAAV,CAAoB,UAApB,GAAiC,UAAU,SAAV,CAAoB,MAArD;AACA,WAAU,SAAV,CAAoB,OAApB,GAA8B,mBAAmB,YAAnB,CAA9B;AACA,WAAU,SAAV,CAAoB,UAApB,GAAiC,UAAU,SAAV,CAAoB,OAArD;AACA,WAAU,SAAV,CAAoB,IAApB,GAA2B,mBAAmB,UAAnB,CAA3B;AACA,WAAU,SAAV,CAAoB,QAApB,GAA+B,UAAU,SAAV,CAAoB,IAAnD;;AAGA,UAAS,cAAT,CAAwB,GAAxB,EAA6B,KAA7B,EAAoC,OAApC,EAA6C;AACzC,SAAM,OAAO,SAAS,EAAtB;;AAEA,SAAM,wBAAN;;;;;;AAMA,SAAM,iBAAiB,CAAvB;;AAEA,SAAM,aAAa,+BAAoB,cAAvC;AACA,SAAM,yCAAN;;AAEA,SAAM,kDAAN;AACA,SAAM,kDAAN;;AAEA,SAAM,QAAQ,yBAAa,UAAb,EAAyB,UAAzB,EAAqC,GAArC,CAAd;;AAEA,SAAM,QAAQ,oBAAQ,gBAAQ;AAC1B,aAAI,iBAAJ;AACA,aAAI,OAAJ,EAAa;AACT,wBAAW,oBAAQ;AAAA,wBACf,KAAK,SAAL,GACM,KAAK,SAAL,CAAe,KAAK,CAAL,CAAf,CADN,GAEM,KAAK,CAAL,CAHS;AAAA,cAAR,EAIP,IAJO,CAAX;AAMH,UAPD,MAOO;AACH,wBAAW,KAAK,SAAL,GACL,oBAAQ,KAAK,SAAb,EAAwB,IAAxB,CADK,GAEL,IAFN;AAGH;;AAED,aAAM,aAAa,UACb,oBAAQ;AAAA,oBAAQ,KAAK,CAAL,CAAR;AAAA,UAAR,EAAyB,IAAzB,CADa,GAEb,IAFN;;AAIA,gBAAO,gBAAS;AACZ,yBADY;AAEZ,mBAAM,QAFM;AAGZ,uBAAU;AAHE,UAAT,CAAP;AAKH,MAxBa,EAwBX,KAxBW,CAAd;;AA0BA,SAAI,YAAY,CAAhB;AACA,SAAI,UAAU,IAAd;AACA,SAAI,iBAAiB,KAArB;AACA,SAAI,MAAM,MAAN,KAAiB,CAArB,EAAwB;AACpB,mBAAU,MAAM,CAAN,CAAV;AACH,MAFD,MAEO;AACH,aAAI,YAAY,KAAhB;;AADG;AAKC,iBAAM,UAAU,yBACZ,kBAAkB,cADN,EAEZ,eAFY,EAGZ,SAHY,CAAhB;AAKA,iBAAI,eAAe,IAAnB;AACA,iBAAM,QAAQ,oBAAQ,iBAAS;;;;;;AAK3B,qBAAM,YAAY,iBACZ,iBAAS;AACP,yBAAM,QAAQ,MAAM,IAAN,CAAW,CAAX,CAAd;AACA,2BAAM,IAAN,GAAa,iBAAK,IAAL,EAAW,MAAM,IAAjB,CAAb,C;AACA,4BAAO,KAAP;AACH,kBALa,GAMZ;AAAA,4BAAS,MAAM,IAAN,CAAW,CAAX,CAAT;AAAA,kBANN;;;;AAUA,qBAAM,YAAY,eACZ,iBAAK,IAAL,EAAW,KAAX,CADY,GAEZ,KAFN;;AAIA,qBAAM,UAAU,oBAAQ,SAAR,EAAmB,SAAnB,CAAhB;;AAEA,gCAAe,KAAf;AACA,wBAAO,wBAAiB;AACpB,iCADoB;AAEpB,2BAAM,OAFc;AAGpB,+BAAU;AAHU,kBAAjB,CAAP;AAKH,cA3Ba,EA2BX,OA3BW,CAAd;;AA6BA,iBAAI,MAAM,MAAN,KAAiB,CAArB,EAAwB;AACxB,yBAAY,KAAZ;AACA,8BAAiB,IAAjB;AACA;AA3CD;;AAIH,gBAAO,UAAU,MAAV,GAAmB,CAA1B,EAA6B;AAAA;;AAAA,mCAoCD;AAI3B;;AAED,mBAAU,UAAU,CAAV,CAAV;AACH;;AAED,SAAM,eAAe,IAArB;AACA,YAAO,IAAI,YAAJ,CAAiB,mBAAO,EAAP,EAAW,IAAX,EAAiB;AACrC,eAAM,OAD+B;AAErC,eAAM,IAAI,MAF2B;AAGrC,iBAAQ;AAH6B,MAAjB,CAAjB,CAAP;AAKH;;AAED,UAAS,eAAT,CAAyB,GAAzB,EAA8B,IAA9B,EAAoC;AAChC,YAAO,eAAe,IAAf,CAAoB,IAApB,EAA0B,GAA1B,EAA+B,IAA/B,EAAqC,IAArC,CAAP;AACH;;AAED,UAAS,gBAAT,CAA0B,GAA1B,EAA+B,IAA/B,EAAqC;AACjC,YAAO,eAAe,IAAf,CAAoB,IAApB,EAA0B,GAA1B,EAA+B,IAA/B,EAAqC,KAArC,CAAP;AACH;;AAED,WAAU,IAAV,GAAiB,eAAjB;;AAEA,WAAU,SAAV,iCAAyC,SAAS,QAAT,GAAoB;AACzD,YAAO,KAAK,KAAL,GACD,KAAK,MAAL,EADC,GAED,KAAK,OAAL,EAFN;AAGH,EAJD;;AAMO,KAAM,wBAAQ,SAAd;;AAEA,UAAS,KAAT,CAAe,KAAf,EAAsB;AACzB,SAAM,OAAO,SAAS,EAAtB;AACA,UAAK,KAAL,GAAa,IAAb;AACA,eAAU,IAAV,CAAe,IAAf,EAAqB,IAArB;AACH;;AAED,OAAM,IAAN,GAAa,gBAAb;;AAEA,OAAM,SAAN,GAAkB,UAAU,SAA5B;;mBAEe,K;;;;;;;;;;;SClqBC,O,GAAA,O;SAuBA,E,GAAA,E;AAjDhB,UAAS,OAAT,CAAiB,SAAjB,EAA4B,KAA5B,EAAmC,KAAnC,EAA0C,GAA1C,EAA+C;AAC3C,SAAM,MAAM,MAAM,MAAlB;AACA,SAAI,QAAQ,CAAR,IAAa,EAAE,YAAY,IAAI,MAAM,CAAN,CAAJ,EAAc,KAAd,KAAwB,CAApC,GAAwC,IAAI,MAAM,CAAN,CAAJ,EAAc,KAAd,IAAuB,CAAjE,CAAjB,EAAsF;AAClF,gBAAO,CAAE,CAAT;AACH;;AAED,SAAI,IAAI,CAAR;AACA,SAAI,IAAI,GAAR;AACA,YAAO,IAAI,CAAJ,GAAQ,CAAf,EAAkB;;;AAGd,aAAM,MAAO,IAAI,CAAL,KAAY,CAAxB;AACA,aAAM,OAAO,MAAM,GAAN,CAAb;AACA,aAAI,YAAY,IAAI,IAAJ,EAAU,KAAV,KAAoB,CAAhC,GAAoC,IAAI,IAAJ,EAAU,KAAV,IAAmB,CAA3D,EAA8D;AAC1D,iBAAI,GAAJ;AACH,UAFD,MAEO;AACH,iBAAI,GAAJ;AACH;AACJ;;AAED,YAAO,CAAP;AACH;;AAEM,KAAM,oBAAM,QAAQ,IAAR,CAAa,IAAb,EAAmB,IAAnB,CAAZ;AACA,KAAM,kBAAK,QAAQ,IAAR,CAAa,IAAb,EAAmB,KAAnB,CAAX;;AAEA,UAAS,OAAT,CAAiB,SAAjB,EAA4B,KAA5B,EAAmC,KAAnC,EAA0C,GAA1C,EAA+C;AAClD,SAAM,MAAM,MAAM,MAAlB;AACA,SAAI,QAAQ,CAAR,IAAa,EAAE,YACT,IAAI,MAAM,MAAM,CAAZ,CAAJ,EAAoB,KAApB,KAA8B,CADrB,GAET,IAAI,MAAM,MAAM,CAAZ,CAAJ,EAAoB,KAApB,IAA6B,CAFtB,CAAjB,EAE2C,OAAO,GAAP;AAC3C,SAAI,IAAI,CAAC,CAAT;AACA,SAAI,IAAI,MAAM,CAAd;AACA,YAAO,IAAI,CAAJ,GAAQ,CAAf,EAAkB;AACd,aAAM,MAAO,IAAI,CAAL,KAAY,CAAxB;AACA,aAAM,OAAO,MAAM,GAAN,CAAb;AACA,aAAI,YAAY,IAAI,IAAJ,EAAU,KAAV,KAAoB,CAAhC,GAAoC,IAAI,IAAJ,EAAU,KAAV,IAAmB,CAA3D,EAA8D;AAC1D,iBAAI,GAAJ;AACH,UAFD,MAEO;AACH,iBAAI,GAAJ;AACH;AACJ;;AAED,YAAO,CAAP;AACH;;AAEM,KAAM,oBAAM,QAAQ,IAAR,CAAa,IAAb,EAAmB,IAAnB,CAAZ;AACA,KAAM,kBAAK,QAAQ,IAAR,CAAa,IAAb,EAAmB,KAAnB,CAAX;;AAEA,UAAS,EAAT,CAAY,KAAZ,EAAmB,KAAnB,EAA0B,GAA1B,EAA+B;AAClC,SAAM,MAAM,IAAI,KAAJ,EAAW,KAAX,EAAkB,GAAlB,CAAZ;AACA,SAAI,QAAQ,CAAC,CAAT,IAAc,IAAI,MAAM,GAAN,CAAJ,EAAgB,KAAhB,MAA2B,CAA7C,EAAgD;AAC5C,gBAAO,GAAP;AACH;AACD,YAAO,CAAE,CAAT;AACH;;mBAEc;AACX,WADW;AAEX,WAFW;AAGX,aAHW;AAIX,aAJW;AAKX;AALW,E;;;;;;;;;;;;;ACzDf;;;;AACA;;AAOA;;;;AAkBA,KAAM,YAAY,uBAAa,EAA/B;;AAEA,KAAM,sBAAsB,SAAtB,mBAAsB,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX;AAAA,YAAoB,uBAAa,GAAb,CAAiB,IAAjB,EAAuB,GAAvB,EAA4B,GAA5B,CAApB;AAAA,EAA5B;;AAEA,UAAS,IAAT,CAAc,KAAd,EAAqB;AACjB,SAAM,OAAO,SAAS,EAAtB;AACA,UAAK,IAAL,GAAY,KAAK,IAAL,IAAa,EAAzB;AACA,UAAK,QAAL,GAAgB,KAAK,QAAL,IAAiB,EAAjC;AACA,UAAK,KAAL;AACA,UAAK,OAAL,GAAe,KAAK,OAApB;AACH;;AAED,QAAO,cAAP,CAAsB,KAAK,SAA3B,EAAsC,MAAtC,EAA8C;AAC1C,iBAAY,IAD8B;AAE1C,QAF0C,iBAEpC;AACF,gBAAO,KAAK,QAAL,CAAc,MAArB;AACH;AAJyC,EAA9C;;AAOA,oBAAO,KAAK,SAAZ,EAAuB;AACnB,yBADmB,kCACI;AACnB,gBAAO,KAAK,QAAL,CAAc,MAAd,IAAwB,KAAK,WAApC;AACH,MAHkB;AAKnB,yBALmB,kCAKI;AACnB,gBAAO,KAAK,QAAL,CAAc,MAAd,IAAwB,KAAK,WAApC;AACH,MAPkB;AASnB,SATmB,gBASd,OATc,EASL;AACV,gBAAO,IAAI,KAAK,WAAT,CAAqB;AACxB,oBAAO,KAAK,KADY;AAExB,mBAAM,iBAAK,OAAL,EAAc,KAAK,IAAnB,CAFkB;AAGxB,uBAAU,iBAAK,OAAL,EAAc,KAAK,QAAnB,CAHc;AAIxB;AAJwB,UAArB,CAAP;AAMH,MAhBkB;AAkBnB,SAlBmB,gBAkBd,OAlBc,EAkBL;AACV,gBAAO,IAAI,KAAK,WAAT,CAAqB;AACxB,oBAAO,KAAK,KADY;AAExB,mBAAM,iBAAK,OAAL,EAAc,KAAK,IAAnB,CAFkB;AAGxB,uBAAU,iBAAK,OAAL,EAAc,KAAK,QAAnB,CAHc;AAIxB;AAJwB,UAArB,CAAP;AAMH,MAzBkB;AA2BnB,gBA3BmB,yBA2BL;AACV,gBAAO,CAAC,KAAK,oBAAL,EAAR;AACH;AA7BkB,EAAvB;;AAgCA,UAAS,IAAT,CAAc,IAAd,EAAoB;AAChB,UAAK,IAAL,CAAU,IAAV,EAAgB,IAAhB;AACH;;AAED,MAAK,SAAL,GAAiB,OAAO,MAAP,CAAc,KAAK,SAAnB,CAAjB;AACA,MAAK,SAAL,CAAe,WAAf,GAA6B,IAA7B;;AAEA,oBAAO,KAAK,SAAZ,EAAuB;AACnB,8CADmB;;AAGnB,8CAHmB;;AAKnB,WALmB,mBAKZ,GALY,EAKP,OALO,EAKE,SALF,EAKa,GALb,EAKkB;AACjC,aAAM,MAAM,UAAU,KAAK,IAAf,EAAqB,GAArB,EAA0B,GAA1B,CAAZ;;AAEA,aAAI,QAAQ,CAAC,CAAb,EAAgB;AACZ,oBAAO,IAAP;AACH;;AAED,4BAAO,SAAP;;AAEA,aAAI,gBAAJ;AACA,aAAM,UAAU,uBAAW,OAAX,EAAoB,GAApB,EAAyB,KAAK,IAA9B,CAAhB;AACA,aAAM,cAAc,uBAAW,OAAX,EAAoB,GAApB,EAAyB,KAAK,QAA9B,CAApB;;AAEA,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,uBAAU,IAAV;AACA,qBAAQ,IAAR,GAAe,OAAf;AACA,qBAAQ,QAAR,GAAmB,WAAnB;AACH,UAJD,MAIO;AACH,uBAAU,IAAI,IAAJ,CAAS;AACf,wBAAO,KAAK,KADG;AAEf,uBAAM,uBAAW,OAAX,EAAoB,GAApB,EAAyB,KAAK,IAA9B,CAFS;AAGf,2BAAU,uBAAW,OAAX,EAAoB,GAApB,EAAyB,KAAK,QAA9B,CAHK;AAIf;AAJe,cAAT,CAAV;AAMH;;AAED,gBAAO,OAAP;AACH,MAhCkB;;;;;;;;;;;;AA2CnB,UA3CmB,iBA2Cb,SA3Ca,EA2CF;AACb,gBAAO,IAAI,IAAJ,CAAS;AACZ,oBAAO,KAAK,KADA;AAEZ,mBAAM,KAAK,IAAL,CAAU,MAAV,CAAiB,UAAU,IAA3B,CAFM;AAGZ,uBAAU,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAU,QAA/B;AAHE,UAAT,CAAP;AAKH,MAjDkB;AAmDnB,cAnDmB,qBAmDT,GAnDS,EAmDJ,GAnDI,EAmDC;AAChB,gBAAO,uBAAa,GAAb,CAAiB,KAAK,IAAtB,EAA4B,GAA5B,EAAiC,GAAjC,CAAP;AACH,MArDkB;AAuDnB,WAvDmB,kBAuDZ,GAvDY,EAuDP,OAvDO,EAuDE,SAvDF,EAuDa,GAvDb,EAuDkB,KAvDlB,EAuDyB;AACxC,aAAM,MAAM,KAAK,SAAL,CAAe,GAAf,EAAoB,GAApB,CAAZ;AACA,aAAM,gBAAgB,KAAK,IAAL,CAAU,GAAV,MAAmB,GAAzC;;AAEA,aAAI,gBAAJ;AACA,aAAI,oBAAJ;;AAEA,aAAI,CAAC,aAAL,EAAoB;AAChB,uBAAU,mBAAO,OAAP,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,KAAK,IAA/B,CAAV;AACA,2BAAc,mBAAO,OAAP,EAAgB,GAAhB,EAAqB,KAArB,EAA4B,KAAK,QAAjC,CAAd;AACH,UAHD,MAGO;AACH,iBAAM,gBAAgB,KAAK,QAAL,CAAc,GAAd,CAAtB;AACA,iBAAI,kBAAkB,KAAtB,EAA6B;AACzB,wBAAO,IAAP;AACH;;AAED,uBAAU,gBAAI,OAAJ,EAAa,GAAb,EAAkB,GAAlB,EAAuB,KAAK,IAA5B,CAAV;AACA,2BAAc,gBAAI,OAAJ,EAAa,GAAb,EAAkB,KAAlB,EAAyB,KAAK,QAA9B,CAAd;AACH;;AAED,4BAAO,SAAP;;AAEA,aAAI,gBAAJ;AACA,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,uBAAU,IAAV;AACA,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,QAAL,GAAgB,WAAhB;AACH,UAJD,MAIO;AACH,uBAAU,IAAI,IAAJ,CAAS;AACf,wBAAO,KAAK,KADG;AAEf,uBAAM,OAFS;AAGf,2BAAU,WAHK;AAIf;AAJe,cAAT,CAAV;AAMH;;AAED,gBAAO,QAAQ,WAAR,KACD,QAAQ,KAAR,CAAc,OAAd,CADC,GAED,OAFN;AAGH,MA9FkB;AAgGnB,UAhGmB,iBAgGb,OAhGa,EAgGJ;AACX,aAAM,SAAS,mBAAO,KAAK,IAAL,CAAU,MAAjB,CAAf;AACA,aAAM,qBAAqB,KAAK,IAAL,CAAU,MAAV,CAA3B;;AAEA,aAAM,UAAU,oBAAQ,OAAR,EAAiB,MAAjB,EAAyB,KAAK,IAA9B,CAAhB;AACA,aAAM,WAAW,QAAQ,CAAR,CAAjB;AACA,aAAM,YAAY,QAAQ,CAAR,CAAlB;;AAEA,aAAM,eAAe,oBAAQ,OAAR,EAAiB,MAAjB,EAAyB,KAAK,QAA9B,CAArB;AACA,aAAM,eAAe,aAAa,CAAb,CAArB;AACA,aAAM,gBAAgB,aAAa,CAAb,CAAtB;;AAEA,aAAM,QAAQ,IAAI,IAAJ,CAAS;AACnB,oBAAO,KAAK,KADO;AAEnB,mBAAM,SAFa;AAGnB,uBAAU,aAHS;AAInB;AAJmB,UAAT,CAAd;;AAOA,aAAI,kBAAJ;AACA,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,yBAAY,IAAZ;AACA,uBAAU,IAAV,GAAiB,QAAjB;AACA,uBAAU,QAAV,GAAqB,YAArB;AACH,UAJD,MAIO;AACH,yBAAY,IAAI,IAAJ,CAAS;AACjB,wBAAO,KAAK,KADK;AAEjB,uBAAM,QAFW;AAGjB,2BAAU,YAHO;AAIjB;AAJiB,cAAT,CAAZ;AAMH;;AAED,gBAAO,CAAC,kBAAD,EAAqB,SAArB,EAAgC,KAAhC,CAAP;AACH,MAlIkB;AAoInB,gBApImB,yBAoIL;AACV,gBAAO,KAAK,IAAL,CAAU,CAAV,CAAP;AACH,MAtIkB;AAwInB,sBAxImB,6BAwID,OAxIC,EAwIQ,YAxIR,EAwIsB;AACrC,aAAM,YAAY,aAAa,IAAb,CAAkB,CAAlB,CAAlB;AACA,aAAM,cAAc,aAAa,QAAb,CAAsB,CAAtB,CAApB;;;;;AAKA,cAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,CAAiB,SAAjB,CAAZ;AACA,cAAK,QAAL,GAAgB,KAAK,QAAL,CAAc,MAAd,CAAqB,WAArB,CAAhB;;AAEA,aAAM,yBAAyB,aAAa,IAAb,CAAkB,OAAlB,CAA/B;AACA,gBAAO,CAAC,IAAD,EAAO,sBAAP,CAAP;AACH,MApJkB;AAsJnB,kBAtJmB,yBAsJL,OAtJK,EAsJI,YAtJJ,EAsJkB;AACjC,aAAM,YAAY,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAlB;AACA,aAAM,cAAc,KAAK,QAAL,CAAc,KAAK,QAAL,CAAc,MAAd,GAAuB,CAArC,CAApB;;;;;AAKA,sBAAa,IAAb,GAAoB,oBAAQ,OAAR,EAAiB,SAAjB,EAA4B,aAAa,IAAzC,CAApB;AACA,sBAAa,QAAb,GAAwB,oBAAQ,OAAR,EAAiB,WAAjB,EAA8B,aAAa,QAA3C,CAAxB;;AAEA,aAAM,qBAAqB,KAAK,IAAL,CAAU,OAAV,CAA3B;AACA,gBAAO,CAAC,kBAAD,EAAqB,YAArB,CAAP;AACH;AAlKkB,EAAvB;;AAqKA,UAAS,YAAT,CAAsB,IAAtB,EAA4B;AACxB,UAAK,IAAL,CAAU,IAAV,EAAgB,IAAhB;AACH;;AAGD,KAAM,UAAU,SAAhB;AACA,KAAM,sBAAsB,qBAA5B;AACA,KAAM,uBAAuB,sBAA7B;AACA,KAAM,QAAQ,OAAd;;AAEO,KAAM,oDAAsB;AAC/B,6CAD+B;AAE/B,+CAF+B;AAG/B;AAH+B,EAA5B;;AAMP,cAAa,SAAb,GAAyB,OAAO,MAAP,CAAc,KAAK,SAAnB,CAAzB;AACA,cAAa,SAAb,CAAuB,WAAvB,GAAqC,YAArC;;AAEA,oBAAO,aAAa,SAApB,EAA+B;AAC3B,kDAD2B;;AAG3B,kDAH2B;;AAK3B,UAL2B,iBAKrB,SALqB,EAKV;;;;;AAKb,aAAM,WAAW,oBAAQ,IAAR,EAAc,UAAU,WAAV,EAAd,EAAuC,UAAU,IAAjD,CAAjB;AACA,aAAM,UAAU,IAAI,YAAJ,CAAiB;AAC7B,oBAAO,KAAK,KADiB;AAE7B,mBAAM,KAAK,IAAL,CAAU,MAAV,CAAiB,QAAjB,CAFuB;AAG7B,uBAAU,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAU,QAA/B;AAHmB,UAAjB,CAAhB;AAKA,gBAAO,OAAP;AACH,MAjB0B;AAmB3B,kCAnB2B,yCAmBG,QAnBH,EAmBa,QAnBb,EAmBuB;;;;;;;AAO9C,aAAI,SAAS,oBAAT,EAAJ,EAAqC;AACjC,oBAAO;AACH,2BAAU;AADP,cAAP;AAGH;;AAED,aAAM,kBAAkB,WAAW,CAAX,GAAe,KAAK,QAAL,CAAc,MAArD;AACA,aAAM,iBAAiB,WAAW,CAAX,IAAgB,CAAvC;;AAEA,aAAM,SAAS,SAAS,WAAT,KAAyB,IAAxC;;AAEA,aAAM,cAAc,EAAE,MAAM,CAAR,EAApB;;AAEA,aAAM,eAAe,kBACf,KAAK,QAAL,CAAc,WAAW,CAAzB,CADe,GAEf,WAFN;;AAIA,aAAM,cAAc,iBACd,KAAK,QAAL,CAAc,WAAW,CAAzB,CADc,GAEd,WAFN;;AAIA,aAAM,cAAc,wEAApB;;AAIA,aAAI,iBAAJ;AACA,aAAI,aAAa,IAAb,IAAqB,YAAY,IAArC,EAA2C;AACvC,iBAAI,aAAa,IAAb,IAAqB,WAAzB,EAAsC;AAClC,4BAAW,KAAX;AACH,cAFD,MAEO;AACH,4BAAW,oBAAX;AACH;;AAED,oBAAO;AACH,2BAAU,QADP;AAEH,4BAAW,YAFR;AAGH,8BAAa,QAHV;AAIH;AAJG,cAAP;AAMH,UAbD,MAaO;AACH,iBAAI,YAAY,IAAZ,IAAoB,WAAxB,EAAqC;AACjC,4BAAW,KAAX;AACH,cAFD,MAEO;AACH,4BAAW,mBAAX;AACH;AACD,oBAAO;AACH,2BAAU,WADP;AAEH,4BAAW,QAFR;AAGH,8BAAa,WAAW,CAHrB;AAIH;AAJG,cAAP;AAMH;AACJ,MA9E0B;AAgF3B,WAhF2B,mBAgFpB,GAhFoB,EAgFf,OAhFe,EAgFN,SAhFM,EAgFK,GAhFL,EAgFU;AACjC,aAAM,WAAW,KAAK,cAAL,CAAoB,GAApB,EAAyB,GAAzB,CAAjB;AACA,aAAM,YAAY,KAAK,QAAL,CAAc,QAAd,CAAlB;AACA,aAAM,QAAQ,UAAU,MAAV,CAAiB,GAAjB,EAAsB,OAAtB,EAA+B,SAA/B,EAA0C,GAA1C,CAAd;;AAEA,aAAI,CAAC,kBAAM,SAAN,CAAL,EAAuB,OAAO,IAAP;;AAEvB,aAAM,eAAe,KAAK,6BAAL,CAAmC,QAAnC,EAA6C,KAA7C,CAArB;AACA,aAAM,WAAW,aAAa,QAA9B;;AAEA,aAAI,aAAa,OAAjB,EAA0B;AACtB,oBAAO,KAAK,oBAAL,CAA0B,OAA1B,EAAmC,QAAnC,EAA6C,CAAC,KAAD,CAA7C,CAAP;AACH;;AAZgC,aAe7B,QAf6B,GAkB7B,YAlB6B,CAe7B,QAf6B;AAAA,aAgB7B,SAhB6B,GAkB7B,YAlB6B,CAgB7B,SAhB6B;AAAA,aAiB7B,WAjB6B,GAkB7B,YAlB6B,CAiB7B,WAjB6B;;;AAoBjC,aAAI,aAAa,KAAjB,EAAwB;AACpB,oBAAO,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,WAAjC,EAA8C,QAA9C,EAAwD,SAAxD,CAAP;AACH;;AAED,aAAI,oBAAJ;AACA,aAAI,qBAAJ;AACA,aAAI,aAAa,oBAAjB,EAAuC;AACnC,iBAAM,WAAW,SAAS,iBAAT,CAA2B,OAA3B,EAAoC,SAApC,CAAjB;AACA,2BAAc,SAAS,CAAT,CAAd;AACA,4BAAe,SAAS,CAAT,CAAf;AACH,UAJD,MAIO,IAAI,aAAa,mBAAjB,EAAsC;AACzC,iBAAM,YAAW,SAAS,aAAT,CAAuB,OAAvB,EAAgC,SAAhC,CAAjB;AACA,2BAAc,UAAS,CAAT,CAAd;AACA,4BAAe,UAAS,CAAT,CAAf;AACH;;AAED,aAAM,uBAAuB,KAAK,oBAAL,CACzB,OADyB,EAEzB,WAFyB,EAGzB,CAAC,WAAD,EAAc,YAAd,CAHyB,CAA7B;;;AAOA,aAAM,kBAAkB,WAAxB;AACA,aAAM,SAAS,aAAa,WAAb,EAAf;;AAEA,8BAAqB,IAArB,GAA4B,gBACxB,OADwB,EAExB,eAFwB,EAGxB,MAHwB,EAIxB,qBAAqB,IAJG,CAA5B;AAMA,gBAAO,oBAAP;AACH,MArI0B;AAuI3B,uBAvI2B,8BAuIR,OAvIQ,EAuIC,YAvID,EAuIe,QAvIf,EAuIyB,SAvIzB,EAuIoC;AAC3D,aAAM,cAAc,SAAS,KAAT,CAAe,SAAf,CAApB;;AAEA,aAAM,cAAc,YAApB;;AAEA,aAAM,UAAU,uBAAW,OAAX,EAAoB,WAApB,EAAiC,KAAK,IAAtC,CAAhB;;AAEA,aAAM,mBAAmB,iBAAiB,CAA1C;;AAEA,aAAI,CAAC,gBAAL,EAAuB;AACnB,qBAAQ,eAAe,CAAvB,IAA4B,YAAY,WAAZ,EAA5B;AACH;;AAED,aAAM,cAAc,uBAAW,KAAK,QAAhB,CAApB;AACA,qBAAY,MAAZ,CAAmB,YAAnB,EAAiC,CAAjC;AACA,qBAAY,YAAZ,IAA4B,WAA5B;;AAEA,aAAM,oBAAoB,IAAI,YAAJ,CAAiB;AACvC,oBAAO,KAAK,KAD2B;AAEvC,mBAAM,OAFiC;AAGvC,uBAAU,WAH6B;AAIvC;AAJuC,UAAjB,CAA1B;AAMA,gBAAO,iBAAP;AACH,MA/J0B;AAiK3B,mBAjK2B,0BAiKZ,GAjKY,EAiKP,GAjKO,EAiKF;AACrB,gBAAO,uBAAa,GAAb,CAAiB,KAAK,IAAtB,EAA4B,GAA5B,EAAiC,GAAjC,IAAwC,CAA/C;AACH,MAnK0B;AAqK3B,sBArK2B,6BAqKT,OArKS,EAqKA,YArKA,EAqKc;;;;;AAKrC,aAAM,cAAc,aAAa,QAAb,CAAsB,CAAtB,CAApB;;AAEA,cAAK,IAAL,GAAY,KAAK,IAAL,CAAU,MAAV,CAAiB,aAAa,WAAb,EAAjB,CAAZ;AACA,cAAK,QAAL,GAAgB,KAAK,QAAL,CAAc,MAAd,CAAqB,WAArB,CAAhB;;AAEA,gBAAO,CAAC,IAAD,EAAO,aAAa,IAAb,CAAkB,OAAlB,CAAP,CAAP;AACH,MAhL0B;AAkL3B,kBAlL2B,yBAkLb,OAlLa,EAkLJ,YAlLI,EAkLU;;AAEjC,aAAM,cAAc,iBAAK,KAAK,QAAV,CAApB;AACA,sBAAa,IAAb,GAAoB,oBAAQ,OAAR,EAAiB,aAAa,WAAb,EAAjB,EAA6C,aAAa,IAA1D,CAApB;AACA,sBAAa,QAAb,GAAwB,oBAAQ,OAAR,EAAiB,WAAjB,EAA8B,aAAa,QAA3C,CAAxB;;AAEA,gBAAO,CAAC,KAAK,IAAL,CAAU,OAAV,CAAD,EAAqB,YAArB,CAAP;AACH,MAzL0B;AA2L3B,yBA3L2B,gCA2LN,OA3LM,EA2LG,GA3LH,EA2LQ,WA3LR,EA2LqB;AAC5C,aAAM,WAAW,sBAAU,KAAK,QAAf,EAAyB,OAAzB,IACX,KAAK,QADM,GAEX,uBAAW,KAAK,QAAhB,CAFN;;AAIA,cAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,YAAY,MAAhC,EAAwC,GAAxC,EAA6C;AACzC,sBAAS,MAAM,CAAf,IAAoB,YAAY,CAAZ,CAApB;AACH;;AAED,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,kBAAK,QAAL,GAAgB,QAAhB;AACA,oBAAO,IAAP;AACH;;AAED,gBAAO,IAAI,YAAJ,CAAiB;AACpB,oBAAO,KAAK,KADQ;AAEpB,mBAAM,KAAK,IAFS;AAGpB,uBAAU,QAHU;AAIpB;AAJoB,UAAjB,CAAP;AAMH,MA/M0B;AAiN3B,gBAjN2B,yBAiNb;AACV,aAAI,OAAO,IAAX;AACA,gBAAO,KAAK,WAAL,KAAqB,IAA5B,EAAkC;AAC9B,oBAAO,KAAK,QAAL,CAAc,CAAd,CAAP;AACH;AACD,gBAAO,KAAK,IAAL,CAAU,CAAV,CAAP;AACH,MAvN0B;AAyN3B,UAzN2B,iBAyNrB,OAzNqB,EAyNZ;AACX,aAAM,YAAY,mBAAO,KAAK,IAAL,CAAU,MAAjB,IAA2B,CAA7C;;AAEA,aAAM,WAAW,4BAAgB,OAAhB,EAAyB,SAAzB,EAAoC,KAAK,IAAzC,CAAjB;AACA,aAAM,WAAW,SAAS,CAAT,CAAjB;AACA,aAAM,YAAY,SAAS,CAAT,CAAlB;AACA,aAAM,YAAY,SAAS,CAAT,CAAlB;;AAEA,aAAM,eAAe,oBAAQ,OAAR,EAAiB,YAAY,CAA7B,EAAgC,KAAK,QAArC,CAArB;AACA,aAAM,eAAe,aAAa,CAAb,CAArB;AACA,aAAM,gBAAgB,aAAa,CAAb,CAAtB;;AAEA,aAAI,iBAAJ;AACA,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,wBAAW,IAAX;AACA,sBAAS,IAAT,GAAgB,QAAhB;AACA,sBAAS,QAAT,GAAoB,YAApB;AACH,UAJD,MAIO;AACH,wBAAW,IAAI,YAAJ,CAAiB;AACxB,wBAAO,KAAK,KADY;AAExB,uBAAM,QAFkB;AAGxB,2BAAU,YAHc;AAIxB;AAJwB,cAAjB,CAAX;AAMH;;AAED,aAAM,YAAY,IAAI,YAAJ,CAAiB;AAC/B,oBAAO,KAAK,KADmB;AAE/B,mBAAM,SAFyB;AAG/B,uBAAU,aAHqB;AAI/B;AAJ+B,UAAjB,CAAlB;;AAOA,gBAAO,CAAC,SAAD,EAAY,QAAZ,EAAsB,SAAtB,CAAP;AACH,MA3P0B;AA6P3B,mBA7P2B,0BA6PZ,GA7PY,EA6PP,OA7PO,EA6PE,MA7PF,EA6PU,UA7PV,EA6PsB,QA7PtB,EA6PgC;AACvD,aAAM,iBAAiB,oBAAoB,GAApB,EAAyB,MAAzB,EAAiC,KAAK,IAAtC,CAAvB;AACA,aAAM,UAAU,mBAAO,OAAP,EAAgB,cAAhB,EAAgC,MAAhC,EAAwC,KAAK,IAA7C,CAAhB;;AAEA,aAAM,cAAc,mBAAO,OAAP,EAAgB,iBAAiB,CAAjC,EAAoC,QAApC,EAA8C,KAAK,QAAnD,CAApB;;AAEA,qBAAY,cAAZ,IAA8B,UAA9B;;AAEA,aAAI,sBAAU,IAAV,EAAgB,OAAhB,CAAJ,EAA8B;AAC1B,kBAAK,IAAL,GAAY,OAAZ;AACA,kBAAK,QAAL,GAAgB,WAAhB;AACA,oBAAO,IAAP;AACH;;AAED,gBAAO,IAAI,YAAJ,CAAiB;AACpB,oBAAO,KAAK,KADQ;AAEpB,mBAAM,OAFc;AAGpB,uBAAU,WAHU;AAIpB;AAJoB,UAAjB,CAAP;AAMH,MAjR0B;AAmR3B,WAnR2B,kBAmRpB,GAnRoB,EAmRf,OAnRe,EAmRN,SAnRM,EAmRK,GAnRL,EAmRU,KAnRV,EAmRiB;AACxC,aAAM,WAAW,KAAK,cAAL,CAAoB,GAApB,EAAyB,GAAzB,CAAjB;AACA,aAAM,QAAQ,KAAK,QAAL,CAAc,QAAd,CAAd;;AAEA,aAAM,WAAW,MAAM,MAAN,CAAa,GAAb,EAAkB,OAAlB,EAA2B,SAA3B,EAAsC,GAAtC,EAA2C,KAA3C,CAAjB;;AAEA,aAAI,CAAC,kBAAM,SAAN,CAAL,EAAuB,OAAO,IAAP;;;;;AAKvB,aAAI,SAAS,MAAT,KAAoB,CAAxB,EAA2B;AACvB,iBAAM,WAAW,QAAjB;AACA,iBAAM,YAAY,SAAS,CAAT,CAAlB;AACA,iBAAM,aAAa,SAAS,CAAT,CAAnB;AACA,iBAAM,YAAY,SAAS,CAAT,CAAlB;;AAEA,iBAAM,iBAAiB,KAAK,cAAL,CACnB,GADmB,EACd,OADc,EACL,SADK,EACM,UADN,EACkB,SADlB,CAAvB;AAEA,oBAAO,eAAe,WAAf,KACD,eAAe,KAAf,CAAqB,OAArB,CADC,GAED,cAFN;AAGH;;AAED,gBAAO,KAAK,oBAAL,CAA0B,OAA1B,EAAmC,QAAnC,EAA6C,CAAC,QAAD,CAA7C,CAAP;AACH;AA5S0B,EAA/B;;SAgTI,I,GAAA,I;SACA,I,GAAA,I;SACA,Y,GAAA,Y;;;;;;;;;;;AC9jBG,KAAM,gDAAoB,CAA1B;;;;;;;;;;;;AAYA,KAAM,wBAAQ,EAAd;AACA,KAAM,gCAAY,CAAlB;;AAEA,KAAM,gDAAoB,KAAK,IAAL,CAAU,QAAQ,CAAlB,IAAuB,CAAjD;AACA,KAAM,gDAAoB,QAAQ,CAAlC;AACA,KAAM,wDAAwB,KAAK,IAAL,CAAU,QAAQ,CAAlB,CAA9B;AACA,KAAM,wDAAwB,KAA9B;;AAEA,KAAM,gDAAoB,OAAO,MAAP,KAAkB,UAAlB,GAC3B,OAAO,QADoB,GAE3B,YAFC,C;;;;;;;;;;;;SCdS,W,GAAA,W;SAIA,U,GAAA,U;SAKA,S,GAAA,S;SAQA,K,GAAA,K;SAsBA,U,GAAA,U;SAUA,U,GAAA,U;SASA,M,GAAA,M;SAuBA,G,GAAA,G;SASA,O,GAAA,O;SASA,O,GAAA,O;SAmBA,O,GAAA,O;SAYA,I,GAAA,I;SAIA,I,GAAA,I;SAWA,I,GAAA,I;SAUA,gB,GAAA,gB;SA4BA,M,GAAA,M;SAmBA,O,GAAA,O;SAIA,M,GAAA,M;SAIA,K,GAAA,K;SAIA,kB,GAAA,kB;;AA5NhB;;AAIO,KAAM,0BAAS,SAAT,MAAS;AAAA,YAAO,KAAK,IAAL,CAAU,MAAM,CAAhB,CAAP;AAAA,EAAf;;AAEA,UAAS,WAAT,GAAuB;AAC1B,YAAO,EAAP;AACH;;AAEM,UAAS,UAAT,CAAoB,GAApB,EAAyB,OAAzB,EAAkC;AACrC,SAAI,OAAJ,GAAc,OAAd;AACA,YAAO,GAAP;AACH;;AAEM,UAAS,SAAT,CAAmB,GAAnB,EAAwB,OAAxB,EAAiC;AACpC,YAAO,WAAW,YAAY,IAAI,OAAlC;AACH;;AAED,UAAS,aAAT,CAAuB,OAAvB,EAAgC,GAAhC,EAAqC;AACjC,YAAO,WAAW,MAAM,IAAI,KAAJ,CAAU,GAAV,CAAN,GAAuB,EAAlC,EAAsC,OAAtC,CAAP;AACH;;AAEM,UAAS,KAAT,CAAe,OAAf,EAAwB,KAAxB,EAA+B,GAA/B,EAAoC,GAApC,EAAyC;AAC5C,SAAM,SAAS,MAAM,KAArB;AACA,SAAI,UAAU,GAAV,EAAe,OAAf,CAAJ,EAA6B;AACzB,aAAI,mBAAmB,KAAvB;AACA,aAAI,iBAAiB,IAAI,MAAJ,GAAa,GAAlC;AACA,gBAAO,kBAAP,EAA2B;AACvB,iBAAI,KAAJ;AACH;AACD,gBAAO,gBAAP,EAAyB;AACrB,iBAAI,GAAJ;AACH;;AAED,gBAAO,GAAP;AACH;;AAED,SAAM,SAAS,cAAc,OAAd,EAAuB,MAAvB,CAAf;AACA,UAAK,IAAI,IAAI,KAAb,EAAoB,IAAI,GAAxB,EAA6B,GAA7B,EAAkC;AAC9B,gBAAO,IAAI,KAAX,IAAoB,IAAI,CAAJ,CAApB;AACH;AACD,YAAO,MAAP;AACH;;AAEM,UAAS,UAAT,CAAoB,GAApB,EAAyB;AAC5B,SAAM,MAAM,IAAI,MAAhB;AACA,SAAM,OAAO,IAAI,KAAJ,CAAU,GAAV,CAAb;;AAEA,UAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,GAApB,EAAyB,GAAzB,EAA8B;AAC1B,cAAK,CAAL,IAAU,IAAI,CAAJ,CAAV;AACH;AACD,YAAO,IAAP;AACH;;AAEM,UAAS,UAAT,CAAoB,OAApB,EAA6B,GAA7B,EAAkC,GAAlC,EAAuC;AAC1C,SAAM,SAAS,UAAU,GAAV,EAAe,OAAf,IACT,GADS,GAET,WAAW,WAAW,GAAX,CAAX,EAA4B,OAA5B,CAFN;;AAIA,YAAO,MAAP,CAAc,GAAd,EAAmB,CAAnB;AACA,YAAO,MAAP;AACH;;AAEM,UAAS,MAAT,CAAgB,OAAhB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC,GAAnC,EAAwC;AAC3C,SAAI,UAAU,GAAV,EAAe,OAAf,CAAJ,EAA6B;AACzB,aAAI,MAAJ,CAAW,GAAX,EAAgB,CAAhB,EAAmB,GAAnB;AACA,gBAAO,GAAP;AACH;;AAED,SAAM,YAAY,IAAI,MAAJ,GAAa,CAA/B;AACA,SAAM,SAAS,IAAI,KAAJ,CAAU,SAAV,CAAf;;AAEA,SAAI,IAAI,CAAR;AACA,YAAO,IAAI,GAAX,EAAgB,GAAhB,EAAqB;AACjB,gBAAO,CAAP,IAAY,IAAI,CAAJ,CAAZ;AACH;;AAED,YAAO,GAAP,IAAc,GAAd;;AAEA,YAAO,IAAI,SAAX,EAAsB,GAAtB,EAA2B;AACvB,gBAAO,CAAP,IAAY,IAAI,IAAI,CAAR,CAAZ;AACH;;AAED,YAAO,MAAP;AACH;;AAEM,UAAS,GAAT,CAAa,OAAb,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC,EAAqC;AACxC,SAAM,SAAS,UAAU,GAAV,EAAe,OAAf,IACT,GADS,GAET,WAAW,WAAW,GAAX,CAAX,EAA4B,OAA5B,CAFN;;AAIA,YAAO,GAAP,IAAc,GAAd;AACA,YAAO,MAAP;AACH;;AAEM,UAAS,OAAT,CAAiB,EAAjB,EAAqB,GAArB,EAA0B;AAC7B,SAAM,SAAS,WAAW,GAAX,CAAf;AACA,SAAM,MAAM,IAAI,MAAhB;AACA,UAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,GAApB,EAAyB,GAAzB,EAA8B;AAC1B,gBAAO,CAAP,IAAY,GAAG,IAAI,CAAJ,CAAH,EAAW,CAAX,CAAZ;AACH;AACD,YAAO,MAAP;AACH;;AAEM,UAAS,OAAT,CAAiB,OAAjB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC;AACvC,SAAM,SAAS,IAAI,MAAnB;AACA,SAAM,cAAc,GAApB;AACA,SAAM,eAAe,SAAS,GAA9B;AACA,SAAM,YAAY,cAAc,OAAd,EAAuB,YAAvB,CAAlB;;AAEA,SAAM,WAAW,cAAc,OAAd,EAAuB,WAAvB,CAAjB;;AAEA,UAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,GAApB,EAAyB,GAAzB,EAA8B;AAC1B,kBAAS,CAAT,IAAc,IAAI,CAAJ,CAAd;AACH;;AAED,UAAK,IAAI,KAAI,GAAb,EAAkB,KAAI,MAAtB,EAA8B,IAA9B,EAAmC;AAC/B,mBAAU,KAAI,GAAd,IAAqB,IAAI,EAAJ,CAArB;AACH;;AAED,YAAO,CAAC,QAAD,EAAW,SAAX,CAAP;AACH;;AAEM,UAAS,OAAT,CAAiB,OAAjB,EAA0B,KAA1B,EAAiC,GAAjC,EAAsC;AACzC,YAAO,OAAO,OAAP,EAAgB,CAAhB,EAAmB,KAAnB,EAA0B,GAA1B,CAAP;AACH;;AAEM,KAAM,4CAAkB,SAAlB,eAAkB,CAAC,OAAD,EAAU,GAAV,EAAe,GAAf,EAAuB;AAClD,SAAM,SAAS,GAAf;AACA,SAAM,QAAQ,MAAd;AACA,SAAM,OAAO,MAAM,OAAN,EAAe,CAAf,EAAkB,KAAlB,EAAyB,GAAzB,CAAb;AACA,SAAM,OAAO,MAAM,OAAN,EAAe,SAAS,CAAxB,EAA2B,IAAI,MAA/B,EAAuC,GAAvC,CAAb;AACA,YAAO,CAAC,IAAD,EAAO,IAAI,MAAJ,CAAP,EAAoB,IAApB,CAAP;AACH,EANM;;AAQA,UAAS,IAAT,CAAc,GAAd,EAAmB;AACtB,YAAO,IAAI,IAAI,MAAJ,GAAa,CAAjB,CAAP;AACH;;AAEM,UAAS,IAAT,CAAc,OAAd,EAAuB,GAAvB,EAA4B;AAC/B,SAAI,UAAU,GAAV,EAAe,OAAf,CAAJ,EAA6B;AACzB,aAAI,IAAI,MAAJ,KAAe,CAAnB,EAAsB,OAAO,GAAP;AACtB,aAAI,GAAJ;AACA,gBAAO,GAAP;AACH;;AAED,SAAI,IAAI,MAAJ,IAAc,CAAlB,EAAqB,OAAO,cAAc,OAAd,CAAP;AACrB,YAAO,MAAM,OAAN,EAAe,CAAf,EAAkB,IAAI,MAAJ,GAAa,CAA/B,EAAkC,GAAlC,CAAP;AACH;;AAEM,UAAS,IAAT,CAAc,OAAd,EAAuB,GAAvB,EAA4B;AAC/B,SAAI,UAAU,GAAV,EAAe,OAAf,CAAJ,EAA6B;AACzB,aAAI,KAAJ;AACA,gBAAO,GAAP;AACH;;AAED,SAAI,IAAI,MAAJ,IAAc,CAAlB,EAAqB,OAAO,WAAW,EAAX,EAAe,OAAf,CAAP;AACrB,YAAO,MAAM,OAAN,EAAe,CAAf,EAAkB,IAAI,MAAtB,EAA8B,GAA9B,CAAP;AACH;;AAEM,UAAS,gBAAT,GAA4B;AAC/B,SAAM,WAAW;AACb,eAAM;AAAA,oBAAO,EAAE,MAAM,IAAR,EAAP;AAAA;AADO,MAAjB;;AAIA,8CAA8B;AAAA,gBAAM,QAAN;AAAA,MAA9B;;AAEA,YAAO,QAAP;AACH;;AAEM,KAAM,sCAAe,SAAf,YAAe,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAmB;AAC3C,SAAM,SAAS,IAAI,MAAnB;AACA,SAAI,CAAC,IAAI,MAAT,EAAiB,OAAO,EAAP;AACjB,SAAI,IAAI,MAAJ,IAAc,GAAlB,EAAuB;AACnB,gBAAO,CAAC,GAAD,CAAP;AACH;;AAED,SAAM,MAAM,KAAK,IAAL,CAAU,CAAC,MAAM,GAAP,IAAc,CAAxB,CAAZ;AACA,SAAM,QAAQ,SAAS,GAAvB;AACA,SAAM,aAAa,KAAK,IAAL,CAAU,KAAV,CAAnB;AACA,SAAM,YAAa,IAAI,UAAL,GAAmB,MAArC;AACA,SAAM,SAAS,IAAI,KAAJ,CAAU,UAAV,CAAf;AACA,UAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAApB,EAAgC,GAAhC,EAAqC;AACjC,gBAAO,CAAP,IAAY,IAAI,KAAJ,CAAU,KAAK,IAAL,CAAU,IAAI,SAAd,CAAV,EAAoC,KAAK,IAAL,CAAU,CAAC,IAAI,CAAL,IAAU,SAApB,CAApC,CAAZ;AACH;AACD,YAAO,MAAP;AACH,EAhBM;;AAkBA,UAAS,MAAT,CAAgB,MAAhB,EAAwB;AAC3B,SAAM,UAAU,UAAU,MAA1B;AACA,SAAI,eAAJ;AACA,SAAI,aAAJ;AACA,SAAI,YAAJ;AACA,SAAI,UAAJ;AACA,SAAI,UAAJ;;AAEA,UAAK,IAAI,CAAT,EAAY,IAAI,OAAhB,EAAyB,GAAzB,EAA8B;AAC1B,kBAAS,UAAU,CAAV,CAAT;AACA,gBAAO,OAAO,IAAP,CAAY,MAAZ,CAAP;AACA,cAAK,IAAI,CAAT,EAAY,IAAI,KAAK,MAArB,EAA6B,GAA7B,EAAkC;AAC9B,mBAAM,KAAK,CAAL,CAAN;AACA,oBAAO,GAAP,IAAc,OAAO,GAAP,CAAd;AACH;AACJ;AACD,YAAO,MAAP;AACH;;AAEM,UAAS,OAAT,CAAiB,KAAjB,EAAwB;AAC3B,YAAO,EAAE,YAAF,EAAP;AACH;;AAEM,UAAS,MAAT,CAAgB,GAAhB,EAAqB;AACxB,SAAI,KAAJ,GAAY,IAAZ;AACH;;AAEM,UAAS,KAAT,CAAe,GAAf,EAAoB;AACvB,YAAO,CAAC,CAAC,IAAI,KAAb;AACH;;AAEM,UAAS,kBAAT,CAA4B,IAA5B,EAAkC;AACrC,YAAO;AACH,eAAM,KAAK,IADR;AAEH,aAAI,KAAK,EAFN;AAGH,wBAAe,KAAK,cAAL,CAAoB,eAApB,IACT,KAAK,aADI,GAET,IALH;AAMH,sBAAa,KAAK,cAAL,CAAoB,aAApB,IACP,KAAK,WADE,GAEP;AARH,MAAP;AAUH,E;;;;;;;;;;;;;ACvOD;;AAGA;;AAIA,KAAM,WAAW,CAAjB;AACA,KAAM,0BAA0B,EAAhC;;AAEO,KAAM,0BAAS,KAAK,KAAL,CAAW,8CAAX,CAAf;;;;;;;;;;;;;;;;;AAiBA,KAAM,8BAAW,SAAX,QAAW,CAAC,OAAD,EAAU,KAAV,EAAiB,GAAjB,EAAyB;;AAE7C,SAAM,OAAO,KAAK,GAAL,CAAS,CAAT,EAAY,KAAZ,IAAqB,CAAlC;;AAEA,YAAO,CAAC,MAAM,IAAP,MAAiB,OAAxB;AACH,EALM;;;;;;;;;;;;;;;;AAqBA,KAAM,4BAAU,SAAV,OAAU,CAAC,QAAD,EAAW,KAAX,EAAkB,IAAlB;AAAA,YACnB,SACI,WAAW,KADf,EAEI,YAAY,QAAQ,CAApB,CAFJ,EAGI,IAHJ,CADmB;AAAA,EAAhB;;;;;;;;;;;;AAiBA,KAAM,4BAAU,SAAV,OAAU,CAAC,QAAD,EAAW,KAAX,EAAkB,IAAlB,EAAwB,QAAxB;AAAA,YACnB,OAAQ,YAAa,WAAW,KADb;AAAA,EAAhB;;AAGA,KAAM,wCAAgB,SAAhB,aAAgB,CAAC,OAAD,EAAU,KAAV,EAAiB,GAAjB,EAAyB;AAClD,SAAM,WAAW,QAAQ,OAAzB;AACA,SAAM,OAAO,KAAK,GAAL,CAAS,CAAT,EAAY,QAAZ,IAAwB,CAArC;AACA,YAAO,MAAM,EAAE,QAAQ,OAAV,CAAb;AACH,EAJM;;;;AAQA,KAAM,oCAAc,SAAd,WAAc,CAAC,QAAD,EAAW,KAAX,EAAkB,IAAlB,EAAwB,QAAxB,EAAqC;AAC5D,SAAM,UAAU,cACZ,WAAW,KADC,EAEZ,YAAY,QAAQ,CAApB,CAFY,EAGZ,IAHY,CAAhB;AAKA,YAAO,QAAQ,QAAR,EAAkB,KAAlB,EAAyB,OAAzB,EAAkC,QAAlC,CAAP;AACH,EAPM;;AASP,UAAS,IAAT,CAAc,QAAd,EAAwB,MAAxB,EAAgC,IAAhC,EAAsC;AAClC,UAAK,QAAL,GAAgB,gCAAhB;AACA,UAAK,MAAL,GAAc,UAAU,MAAxB;AACA,UAAK,KAAL,GAAa,QAAQ,CAArB;AACH;;AAED,MAAK,UAAL,GAAkB,IAAI,IAAJ,uBAAoB,MAApB,EAA4B,QAA5B,CAAlB;AACA,MAAK,IAAL,GAAY,SAAS,IAAT,CAAc,GAAd,EAAmB;AAC3B,SAAM,SAAS,IAAI,MAAnB;;AAEA,SAAI,OAAO,CAAX;AACA,UAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAApB,EAA4B,GAA5B,EAAiC;AAC7B,gBAAO,8BAAmB,CAAnB,EAAsB,IAAtB,EAA4B,IAAI,CAAJ,CAA5B,CAAP;AACH;;AAED,YAAO,IAAI,IAAJ,uBAAoB,MAApB,EAA4B,IAA5B,CAAP;AACH,EATD;;AAWA,oBAAO,KAAK,SAAZ,EAAuB;AACnB,QADmB,eACf,KADe,EACR;AACP,gBAAO,QAAQ,KAAK,QAAb,EAAuB,KAAvB,EAA8B,KAAK,KAAnC,CAAP;AACH,MAHkB;AAKnB,WALmB,kBAKZ,SALY,EAKD;AACd,gBAAO,KAAK,KAAL,KAAe,UAAU,KAAhC;AACH,MAPkB;AASnB,eATmB,sBASR,KATQ,EASD;AACd,aAAI,YAAY,QAAQ,CAAxB;AACA,aAAI,UAAU,IAAd;AACA,gBAAO,YAAY,KAAK,MAAxB,EAAgC;AAC5B,uBAAU,QAAQ,GAAR,CAAY,SAAZ,EAAuB,CAAvB,CAAV;AACA;AACH;AACD,gBAAO,OAAP;AACH,MAjBkB;AAmBnB,YAnBmB,qBAmBT;AACN,aAAM,MAAM,IAAI,KAAJ,CAAU,KAAK,MAAf,CAAZ;AACA,cAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,iBAAI,CAAJ,IAAS,KAAK,GAAL,CAAS,CAAT,CAAT;AACH;AACD,gBAAO,GAAP;AACH,MAzBkB;AA2BnB,cA3BmB,qBA2BT,SA3BS,EA2BE;AACjB,aAAM,IAAI,KAAK,KAAf;AACA,aAAM,IAAI,UAAU,KAApB;AACA,gBAAO,MAAM,CAAN,GAAU,CAAV,GAAc,IAAI,CAAJ,GAAQ,CAAE,CAAV,GAAc,CAAnC,C;AACH,MA/BkB;AAiCnB,cAjCmB,qBAiCT,KAjCS,EAiCF;AACb,aAAM,UAAU,KAAK,GAAL,CAAS,KAAT,EAAgB,KAAK,GAAL,CAAS,KAAT,IAAkB,CAAlC,CAAhB;AACA,gBAAO,QAAQ,UAAR,CAAmB,KAAnB,CAAP;AACH,MApCkB;AAsCnB,cAtCmB,qBAsCT,KAtCS,EAsCF;AACb,gBAAO,KAAK,GAAL,CAAS,KAAT,EAAgB,KAAK,GAAL,CAAS,KAAT,IAAkB,CAAlC,CAAP;AACH,MAxCkB;AA0CnB,QA1CmB,eA0Cf,KA1Ce,EA0CR,KA1CQ,EA0CD;AACd,aAAM,UAAU,YAAY,KAAK,QAAjB,EAA2B,KAA3B,EAAkC,KAAK,KAAvC,EAA8C,KAA9C,CAAhB;AACA,gBAAO,IAAI,IAAJ,CAAS,KAAK,QAAd,EAAwB,KAAK,MAA7B,EAAqC,OAArC,CAAP;AACH;AA7CkB,EAAvB;;SAgDS,I,GAAA,I;mBACM,I","file":"ibtree.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ibtree\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ibtree\"] = factory();\n\telse\n\t\troot[\"ibtree\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 62e052541210e27598bb\n **/","import binarySearch from './binarysearch';\nimport { Leaf, InternalNode } from './nodes';\nimport Path from './path';\nimport {\n    fastMap,\n    getEmptyIterator,\n    tail,\n    boundedChunk,\n    extend,\n    makeOwnerID,\n    tagOwnerID,\n    makeRef,\n    isSet,\n    normalizeRangeSpec,\n} from './utils';\nimport {\n    ORDER,\n    MIN_ROOT_CHILDREN,\n    SHIFT_LEN,\n    LEAF_MIN_CHILDREN,\n    LEAF_MAX_CHILDREN,\n    INTERNAL_MIN_CHILDREN,\n    INTERNAL_MAX_CHILDREN,\n    ITERATOR_PROPNAME,\n} from './constants';\n\nconst binSearch = binarySearch.eq;\n\nconst NOT_FOUND = {};\n\n\nexport const defaultComparator = (a, b) => // eslint-disable-line no-confusing-arrow\n    a === b // eslint-disable-line no-nested-ternary\n        ? 0\n        : a < b\n            ? -1\n            : 1;\n\n\n// Iterator extraction funcs\n\nconst extractValue = (leaf, idx) => leaf.children[idx];\nconst extractKey = (leaf, idx) => leaf.keys[idx];\nconst extractEntry = (leaf, idx) => [extractKey(leaf, idx), extractValue(leaf, idx)];\n\n\nexport function BPlusTree(_opts) {\n    const opts = _opts || {};\n    this.order = ORDER;\n\n    // Used to decide whether @@iterator returns\n    // values or entries.\n    this.isSet = opts.isSet === undefined ? false : opts.isSet;\n\n    this.extractor = opts.extractor; // May be undefined on purpose.\n    this.comparator = opts.comparator || defaultComparator;\n\n    this.root = opts.root || new Leaf({ order: this.order });\n    this.size = opts.size || 0;\n    this.height = opts.height || 0;\n    this.ownerID = opts.ownerID;\n}\n\nextend(BPlusTree.prototype, {\n    has(key) {\n        return this.search(this.comparator, key) !== NOT_FOUND;\n    },\n\n    add(value) {\n        return this.set(value, value);\n    },\n\n    get(key) {\n        const val = this.search(this.comparator, key);\n        return val === NOT_FOUND\n            ? undefined\n            : val;\n    },\n\n    clear() {\n        return new this.constructor({\n            comparator: this.comparator,\n            extractor: this.extractor,\n        });\n    },\n\n    set(key, value) {\n        const cmp = this.comparator;\n        const extractedKey = this.extractor\n            ? this.extractor(key)\n            : key;\n\n        const didChange = makeRef(false);\n        const result = this.root.insert(cmp, this.ownerID, didChange, extractedKey, value);\n\n        if (!isSet(didChange)) return this;\n\n        let newRoot;\n        let rootSplit = false;\n        const canMutate = !!this.ownerID;\n\n        // Root was split\n        if (result.length === 3) {\n            rootSplit = true;\n            const splitArr = result;\n            const medianKey = splitArr[0];\n            const splitChild = splitArr[1];\n            const newChild = splitArr[2];\n\n            const newRootKeys = tagOwnerID([medianKey], this.ownerID);\n            const newRootChildren = tagOwnerID([splitChild, newChild], this.ownerID);\n\n            newRoot = new InternalNode({\n                order: this.order,\n                keys: newRootKeys,\n                children: newRootChildren,\n            });\n        } else {\n            newRoot = result;\n        }\n\n        const newHeight = rootSplit ? this.height + 1 : this.height;\n        const newSize = this.size + 1;\n\n        if (canMutate) {\n            this.height = newHeight;\n            this.size = newSize;\n            this.root = newRoot;\n            this._didAlter = true;\n            return this;\n        }\n        return new this.constructor({\n            extractor: this.extractor,\n            comparator: this.comparator,\n            root: newRoot,\n            height: newHeight,\n            size: newSize,\n            ownerID: this.ownerID,\n        });\n    },\n\n    delete(key) {\n        const didChange = makeRef(false);\n        let newRoot = this.root.delete(\n            this.comparator,\n            this.ownerID,\n            didChange,\n            key\n        );\n\n        if (!isSet(didChange)) return this;\n\n        let rootMerged = false;\n        if (newRoot.size < MIN_ROOT_CHILDREN) {\n            const isLeaf = newRoot.constructor === Leaf;\n            if (!isLeaf) {\n                // Since the minimum number of children in\n                // the root is 2, the root must have a single\n                // child.\n                newRoot = newRoot.children[0];\n                rootMerged = true;\n            }\n            // If the root is a leaf, it can be empty.\n        }\n\n        const canMutate = !!this.ownerID;\n\n        let newTree;\n        const newHeight = rootMerged ? this.height - 1 : this.height;\n        const newSize = this.size - 1;\n\n        if (canMutate) {\n            newTree = this;\n            this.root = newRoot;\n            this.height = newHeight;\n            this.size = newSize;\n            this._didAlter = true;\n        } else {\n            newTree = new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: newRoot,\n                height: newHeight,\n                size: newSize,\n                ownerID: this.ownerID,\n            });\n        }\n        return newTree;\n    },\n\n    asMutable() {\n        return this.ownerID\n            ? this\n            : new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: this.root,\n                height: this.height,\n                size: this.size,\n                ownerID: makeOwnerID(),\n            });\n    },\n\n    asImmutable() {\n        return this.ownerID\n            ? new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: this.root,\n                height: this.height,\n                size: this.size,\n            })\n            : this;\n    },\n\n    withMutations(fn) {\n        const mutable = this.asMutable();\n        fn(mutable);\n        return mutable._didAlter ? mutable.asImmutable() : this;\n    },\n\n    _baseBetween(extractor, _rangeSpec) {\n        if (this.size === 0) return getEmptyIterator();\n\n        const rangeSpec = normalizeRangeSpec(_rangeSpec);\n\n        const fromKey = this.extractor\n            ? this.extractor(rangeSpec.from)\n            : rangeSpec.from;\n\n        const toKey = this.extractor\n            ? this.extractor(rangeSpec.to)\n            : rangeSpec.to;\n\n        const isReverse = this.comparator(fromKey, toKey) > 0;\n\n        const fromIsRight = isReverse;\n        const toIsRight = !fromIsRight;\n\n        const fromPath = this.findPath(fromKey, fromIsRight, rangeSpec.fromInclusive);\n        const toPath = this.findPath(toKey, toIsRight, rangeSpec.toInclusive);\n\n        if (fromPath === null || toPath === null) {\n            return getEmptyIterator();\n        }\n\n        return this._iteratorFromTo(\n            extractor,\n            fromPath,\n            toPath,\n            isReverse\n        );\n    },\n\n    between(fromKey, toKey) {\n        if (arguments.length === 1) {\n            const rangeSpec = arguments[0];\n            return this._baseBetween(extractEntry, rangeSpec);\n        }\n\n        const spec = {\n            from: fromKey,\n            to: toKey,\n        };\n\n        return this._baseBetween(extractEntry, spec);\n    },\n\n    /**\n     * Returns the internal and leaf nodes\n     * on the path from root to value.\n     *\n     * @param  {Path} path\n     * @return {Array[Node]}\n     */\n    _pathNodes(path) {\n        const nodes = new Array(path.length);\n\n        let curr = this.root;\n        for (let i = 0; i < path.length; i++) {\n            nodes[i] = curr;\n            curr = curr.children[path.get(i)];\n        }\n\n        return nodes;\n    },\n\n    _nextPath(path) {\n        const nodes = this._pathNodes(path);\n        let level = nodes.length - 1;\n\n        // Simple case: leaf index can be incremented.\n        if (path.get(level) < nodes[level].children.length - 1) {\n            return path.increment(level);\n        }\n\n        level--;\n        // Go through the node path starting from the lowest internal node and\n        // find the first node we can increment a key for.\n        while (level >= 0 && path.get(level) === nodes[level].children.length - 1) level--;\n        // All nodes were at their maximum key\n        if (level < 0) return null;\n        return path.increment(level);\n    },\n\n    _prevPath(path) {\n        // Leftmost path - can't decrement.\n        if (path.equals(Path.EMPTY_PATH)) return null;\n\n        const nodes = this._pathNodes(path);\n\n        let level = path.length - 1;\n        while (path.get(level) === 0) level--;\n\n        let newPath = path.set(level, path.get(level) - 1);\n\n        // Set all the lower keys to their\n        // maximum value.\n        let curr = nodes[level].children[newPath.get(level)];\n        level++;\n        for (; level < path.length; level++) {\n            const childLen = curr.children.length;\n            newPath = newPath.set(level, childLen - 1);\n            curr = curr.children[childLen - 1];\n        }\n        return newPath;\n    },\n\n    _iterateAllWithExtractFn(extractFn) {\n        if (this.size === 0) return getEmptyIterator();\n\n        return this._iteratorFromTo(\n            extractFn,\n            this._getLeftmostPath(),\n            this._getRightmostPath()\n        );\n    },\n\n    _getLeafFromPath(path) {\n        const level = this.height;\n\n        let currLevel = 0;\n        let currNode = this.root;\n\n        while (currLevel !== level) {\n            currNode = currNode.children[path.get(currLevel++)];\n        }\n        return currNode;\n    },\n\n    _getRightmostPath() {\n        if (this.size === 0) return null;\n\n        const keypath = [];\n        let curr = this.root;\n        let currLevel = 0;\n        const leafLevel = this.height;\n\n        while (currLevel !== leafLevel + 1) {\n            const idx = curr.children.length - 1;\n            keypath.push(idx);\n            curr = curr.children[idx];\n            currLevel++;\n        }\n        return Path.from(keypath);\n    },\n\n    _getLeftmostPath() {\n        if (this.size === 0) {\n            return null;\n        }\n\n        return new Path(SHIFT_LEN, this.height + 1);\n    },\n\n    _iteratorFromTo(extractFn, fromPath, toPath, isReverse) {\n        const getPathSuccessor = isReverse\n            ? this._prevPath.bind(this)\n            : this._nextPath.bind(this);\n\n        const leafLevel = this.height;\n\n        let currPath = fromPath;\n\n        // Most of the time we're just getting the next\n        // value from a leaf, so it makes sense to cache\n        // the leaf instead of looking up the successor\n        // path each time.\n        let leafCacheRef;\n        let done = false;\n        const iterator = {\n            next: () => {\n                const pathsEq = currPath !== null && currPath.equals(toPath);\n                if (currPath !== null && (!pathsEq || !done)) {\n                    const valIdx = currPath.get(leafLevel);\n                    const leaf = leafCacheRef || this._getLeafFromPath(currPath);\n                    if (!pathsEq) {\n                        if (isReverse && valIdx > 0) {\n                            // Can decrement leaf index\n                            currPath = currPath.decrement(leafLevel);\n                        } else if (!isReverse && valIdx < leaf.children.length - 1) {\n                            // Can increment leaf idx\n                            currPath = currPath.increment(leafLevel);\n                        } else {\n                            currPath = getPathSuccessor(currPath);\n                            leafCacheRef = undefined;\n                        }\n                    } else {\n                        done = true;\n                    }\n\n                    const value = extractFn(leaf, valIdx);\n\n                    return {\n                        value,\n                    };\n                }\n\n                return {\n                    done: true,\n                };\n            },\n        };\n\n        iterator[ITERATOR_PROPNAME] = () => iterator;\n\n        return iterator;\n    },\n\n    findPath(key, fromRight, isInclusive) {\n        if (this.size === 0) return null;\n\n        const cmp = this.comparator;\n\n        let curr = this.root;\n        const numAccessesToReachLeaf = this.height;\n\n        // Path needs one more value (which key to look up in leaf)\n        const keypath = new Array(numAccessesToReachLeaf + 1);\n\n        let i = 0;\n        let prev = curr;\n        for (; i < numAccessesToReachLeaf; i++) {\n            const idx = curr.childIdxForKey(cmp, key);\n            keypath[i] = idx;\n            prev = curr;\n            curr = curr.children[idx];\n        }\n\n        const parent = prev;\n\n        const searchFuncName = (fromRight ? 'lt' : 'gt') + (isInclusive ? 'e' : '');\n        const searchFunc = binarySearch[searchFuncName];\n\n        // curr should be a leaf now.\n        const idx = searchFunc(curr.keys, key, cmp);\n\n        if (idx === curr.keys.length) {\n            if (!fromRight) {\n                // The key we're looking for could be in the right leaf.\n                keypath[i - 1]++;\n\n                const hasRightLeaf = keypath[i - 1] < parent.children.length;\n                if (!hasRightLeaf) return null;\n                curr = parent.children[keypath[i - 1]];\n                if (curr.keys[0] >= key) {\n                    keypath[i] = 0;\n                } else {\n                    // out of bounds.\n                    return null;\n                }\n            } else {\n                keypath[i] = idx - 1;\n            }\n        } else if (idx === -1) {\n            if (fromRight) {\n                // the key we're looking for could be in the left leaf.\n                keypath[i - 1]--;\n\n                const hasLeftLeaf = keypath[i - 1] >= 0;\n                if (!hasLeftLeaf) return null;\n\n                curr = parent.children[keypath[i - 1]];\n                if (curr.keys[curr.keys.length - 1] <= key) {\n                    keypath[i] = curr.keys.length - 1;\n                } else {\n                    // out of bounds.\n                    return null;\n                }\n            } else {\n                keypath[i] = 0;\n            }\n        } else {\n            keypath[i] = idx;\n        }\n\n        return Path.from(keypath);\n    },\n\n    findLeaf(cmp, key) {\n        let curr = this.root;\n        const numAccessesToReachLeaf = this.height;\n        for (let i = 0; i < numAccessesToReachLeaf; i++) {\n            const idx = curr.childIdxForKey(cmp, key);\n            curr = curr.children[idx];\n        }\n\n        return curr;\n    },\n\n    search(cmp, key) {\n        const extractedKey = this.extractor\n            ? this.extractor(key)\n            : key;\n\n        const leaf = this.findLeaf(cmp, extractedKey);\n        const idx = binSearch(leaf.keys, extractedKey, cmp);\n        if (idx === -1) {\n            return NOT_FOUND;\n        }\n\n        return leaf.children[idx];\n    },\n\n    visit(fn) {\n        const queue = [this.root];\n        while (queue.length) {\n            const curr = queue.shift();\n            fn(curr);\n            if (curr.constructor !== Leaf && curr.children) {\n                queue.push(...curr.children);\n            }\n        }\n    },\n});\n\nconst makeIteratorMethod = extractor =>\n    function getRangeIterator() {\n        if (arguments.length === 0) {\n            return this._iterateAllWithExtractFn(extractor);\n        } else if (arguments.length === 1) {\n            const spec = arguments[0];\n            this._baseBetween(\n                extractor,\n                spec\n            );\n        }\n\n        const spec = {\n            from: arguments[0],\n            to: arguments[1],\n        };\n\n        return this._baseBetween(extractor, spec);\n    };\n\n\nBPlusTree.prototype.values = makeIteratorMethod(extractValue);\nBPlusTree.prototype.valueRange = BPlusTree.prototype.values;\nBPlusTree.prototype.entries = makeIteratorMethod(extractEntry);\nBPlusTree.prototype.entryRange = BPlusTree.prototype.entries;\nBPlusTree.prototype.keys = makeIteratorMethod(extractKey);\nBPlusTree.prototype.keyRange = BPlusTree.prototype.keys;\n\n\nfunction fromSortedBase(arr, _opts, isPairs) {\n    const opts = _opts || {};\n\n    const order = ORDER;\n\n    // For leftmost nodes, we don't take a key\n    // to their parent. That means the parent\n    // could have one too few children, if it's\n    // already at minimum. This adjusts for that.\n    const MIN_ADJUSTMENT = 1;\n\n    const minPageLen = LEAF_MIN_CHILDREN + MIN_ADJUSTMENT;\n    const maxPageLen = LEAF_MAX_CHILDREN;\n\n    const minNodeChildren = INTERNAL_MIN_CHILDREN;\n    const maxNodeChildren = INTERNAL_MAX_CHILDREN;\n\n    const pages = boundedChunk(minPageLen, maxPageLen, arr);\n\n    const leafs = fastMap(page => {\n        let leafKeys;\n        if (isPairs) {\n            leafKeys = fastMap(item =>\n                opts.extractor\n                    ? opts.extractor(item[0])\n                    : item[0],\n                page\n            );\n        } else {\n            leafKeys = opts.extractor\n                ? fastMap(opts.extractor, page)\n                : page;\n        }\n\n        const leafValues = isPairs\n            ? fastMap(item => item[1], page)\n            : page;\n\n        return new Leaf({\n            order,\n            keys: leafKeys,\n            children: leafValues,\n        });\n    }, pages);\n\n    let newHeight = 0;\n    let newRoot = null;\n    let leafsProcessed = false;\n    if (leafs.length === 1) {\n        newRoot = leafs[0];\n    } else {\n        let currLevel = leafs;\n\n\n        while (currLevel.length > 1) {\n            const chunked = boundedChunk(\n                minNodeChildren + MIN_ADJUSTMENT,\n                maxNodeChildren,\n                currLevel\n            );\n            let firstInChunk = true;\n            const nodes = fastMap(chunk => { // eslint-disable-line\n                // For leafs, we use the first key as the key\n                // for the whole chunk.\n                // For internal nodes, we move the first\n                // key up a level.\n                const operation = leafsProcessed\n                    ? child => {\n                        const _head = child.keys[0];\n                        child.keys = tail(null, child.keys); // eslint-disable-line\n                        return _head;\n                    }\n                    : child => child.keys[0];\n\n                // For the left-most nodes, we don't\n                // take a key from its children.\n                const operateOn = firstInChunk\n                    ? tail(null, chunk)\n                    : chunk;\n\n                const newKeys = fastMap(operation, operateOn);\n\n                firstInChunk = false;\n                return new InternalNode({\n                    order,\n                    keys: newKeys,\n                    children: chunk,\n                });\n            }, chunked);\n\n            if (nodes.length === 0) break;\n            currLevel = nodes;\n            leafsProcessed = true;\n            newHeight++;\n        }\n\n        newRoot = currLevel[0];\n    }\n\n    const _constructor = this;\n    return new _constructor(extend({}, opts, {\n        root: newRoot,\n        size: arr.length,\n        height: newHeight,\n    }));\n}\n\nfunction fromSortedPairs(arr, opts) {\n    return fromSortedBase.call(this, arr, opts, true);\n}\n\nfunction fromSortedValues(arr, opts) {\n    return fromSortedBase.call(this, arr, opts, false);\n}\n\nBPlusTree.from = fromSortedPairs;\n\nBPlusTree.prototype[ITERATOR_PROPNAME] = function iterator() {\n    return this.isSet\n        ? this.values()\n        : this.entries();\n};\n\nexport const BTMap = BPlusTree;\n\nexport function BTSet(_opts) {\n    const opts = _opts || {};\n    opts.isSet = true;\n    BPlusTree.call(this, opts);\n}\n\nBTSet.from = fromSortedValues;\n\nBTSet.prototype = BPlusTree.prototype;\n\nexport default BTMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","function baseLte(inclusive, array, value, cmp) {\n    const len = array.length;\n    if (len === 0 || !(inclusive ? cmp(array[0], value) <= 0 : cmp(array[0], value) < 0)) {\n        return - 1;\n    }\n\n    let l = 0;\n    let r = len;\n    while (r - l > 1) {\n        // In our case, r + l <= 128 so we don't need\n        // to worry about overflow here\n        const mid = (r + l) >>> 1;\n        const item = array[mid];\n        if (inclusive ? cmp(item, value) <= 0 : cmp(item, value) < 0) {\n            l = mid;\n        } else {\n            r = mid;\n        }\n    }\n\n    return l;\n}\n\nexport const lte = baseLte.bind(null, true);\nexport const lt = baseLte.bind(null, false);\n\nexport function baseGte(inclusive, array, value, cmp) {\n    const len = array.length;\n    if (len === 0 || !(inclusive\n            ? cmp(array[len - 1], value) >= 0\n            : cmp(array[len - 1], value) > 0)) return len;\n    let l = -1;\n    let r = len - 1;\n    while (r - l > 1) {\n        const mid = (r + l) >>> 1;\n        const item = array[mid];\n        if (inclusive ? cmp(item, value) >= 0 : cmp(item, value) > 0) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n\n    return r;\n}\n\nexport const gte = baseGte.bind(null, true);\nexport const gt = baseGte.bind(null, false);\n\nexport function eq(array, value, cmp) {\n    const idx = lte(array, value, cmp);\n    if (idx !== -1 && cmp(array[idx], value) === 0) {\n        return idx;\n    }\n    return - 1;\n}\n\nexport default {\n    lt,\n    gt,\n    lte,\n    gte,\n    eq,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binarysearch.js\n **/","import binarySearch from './binarysearch';\nimport {\n    ORDER,\n    LEAF_MIN_CHILDREN,\n    LEAF_MAX_CHILDREN,\n    INTERNAL_MIN_CHILDREN,\n    INTERNAL_MAX_CHILDREN,\n} from './constants';\nimport {\n    takeIdxAndSplit,\n    insert,\n    set,\n    arrayClone,\n    unshift,\n    splitAt,\n    withoutIdx,\n    last,\n    init,\n    tail,\n    median,\n    extend,\n    setRef,\n    isSet,\n    canMutate,\n} from './utils';\n\nconst binSearch = binarySearch.eq;\n\nconst internalInsertKeyAt = (cmp, key, keys) => binarySearch.gte(keys, key, cmp);\n\nfunction Node(_opts) {\n    const opts = _opts || {};\n    this.keys = opts.keys || [];\n    this.children = opts.children || [];\n    this.order = ORDER;\n    this.ownerID = opts.ownerID;\n}\n\nObject.defineProperty(Node.prototype, 'size', {\n    enumerable: true,\n    get() {\n        return this.children.length;\n    },\n});\n\nextend(Node.prototype, {\n    satisfiesMinChildren() {\n        return this.children.length >= this.minChildren;\n    },\n\n    satisfiesMaxChildren() {\n        return this.children.length <= this.maxChildren;\n    },\n\n    tail(ownerID) {\n        return new this.constructor({\n            order: this.order,\n            keys: tail(ownerID, this.keys),\n            children: tail(ownerID, this.children),\n            ownerID,\n        });\n    },\n\n    init(ownerID) {\n        return new this.constructor({\n            order: this.order,\n            keys: init(ownerID, this.keys),\n            children: init(ownerID, this.children),\n            ownerID,\n        });\n    },\n\n    shouldSplit() {\n        return !this.satisfiesMaxChildren();\n    },\n});\n\nfunction Leaf(opts) {\n    Node.call(this, opts);\n}\n\nLeaf.prototype = Object.create(Node.prototype);\nLeaf.prototype.constructor = Leaf;\n\nextend(Leaf.prototype, {\n    maxChildren: LEAF_MAX_CHILDREN,\n\n    minChildren: LEAF_MIN_CHILDREN,\n\n    delete(cmp, ownerID, didChange, key) {\n        const idx = binSearch(this.keys, key, cmp);\n        // Key was not found. No modifications needed.\n        if (idx === -1) {\n            return this;\n        }\n\n        setRef(didChange);\n\n        let newLeaf;\n        const newKeys = withoutIdx(ownerID, idx, this.keys);\n        const newChildren = withoutIdx(ownerID, idx, this.children);\n\n        if (canMutate(this, ownerID)) {\n            newLeaf = this;\n            newLeaf.keys = newKeys;\n            newLeaf.children = newChildren;\n        } else {\n            newLeaf = new Leaf({\n                order: this.order,\n                keys: withoutIdx(ownerID, idx, this.keys),\n                children: withoutIdx(ownerID, idx, this.children),\n                ownerID,\n            });\n        }\n\n        return newLeaf;\n    },\n\n    /**\n     * Returns a new leaf with entries merged\n     * from `otherLeaf`. The keys in `otherLeaf`\n     * must be higher than in the current leaf,\n     * i.e. `otherLeaf` must reside to the right of\n     * this leaf in the tree.\n     * @param  {Leaf} otherLeaf - other leaf to merge\n     * @return {Leaf} a new Leaf with entries merged.\n     */\n    merge(otherLeaf) {\n        return new Leaf({\n            order: this.order,\n            keys: this.keys.concat(otherLeaf.keys),\n            children: this.children.concat(otherLeaf.children),\n        });\n    },\n\n    idxForKey(cmp, key) {\n        return binarySearch.gte(this.keys, key, cmp);\n    },\n\n    insert(cmp, ownerID, didChange, key, value) {\n        const idx = this.idxForKey(cmp, key);\n        const alreadyHasKey = this.keys[idx] === key;\n\n        let newKeys;\n        let newChildren;\n\n        if (!alreadyHasKey) {\n            newKeys = insert(ownerID, idx, key, this.keys);\n            newChildren = insert(ownerID, idx, value, this.children);\n        } else {\n            const existingValue = this.children[idx];\n            if (existingValue === value) {\n                return this;\n            }\n\n            newKeys = set(ownerID, idx, key, this.keys);\n            newChildren = set(ownerID, idx, value, this.children);\n        }\n\n        setRef(didChange);\n\n        let newLeaf;\n        if (canMutate(this, ownerID)) {\n            newLeaf = this;\n            this.keys = newKeys;\n            this.children = newChildren;\n        } else {\n            newLeaf = new Leaf({\n                order: this.order,\n                keys: newKeys,\n                children: newChildren,\n                ownerID,\n            });\n        }\n\n        return newLeaf.shouldSplit()\n            ? newLeaf.split(ownerID)\n            : newLeaf;\n    },\n\n    split(ownerID) {\n        const cutoff = median(this.keys.length);\n        const smallestKeyInOther = this.keys[cutoff];\n\n        const keypair = splitAt(ownerID, cutoff, this.keys);\n        const thisKeys = keypair[0];\n        const otherKeys = keypair[1];\n\n        const childrenPair = splitAt(ownerID, cutoff, this.children);\n        const thisChildren = childrenPair[0];\n        const otherChildren = childrenPair[1];\n\n        const other = new Leaf({\n            order: this.order,\n            keys: otherKeys,\n            children: otherChildren,\n            ownerID,\n        });\n\n        let thisSplit;\n        if (canMutate(this, ownerID)) {\n            thisSplit = this;\n            thisSplit.keys = thisKeys;\n            thisSplit.children = thisChildren;\n        } else {\n            thisSplit = new Leaf({\n                order: this.order,\n                keys: thisKeys,\n                children: thisChildren,\n                ownerID,\n            });\n        }\n\n        return [smallestKeyInOther, thisSplit, other];\n    },\n\n    smallestKey() {\n        return this.keys[0];\n    },\n\n    stealFirstKeyFrom(ownerID, rightSibling) {\n        const stolenKey = rightSibling.keys[0];\n        const stolenValue = rightSibling.children[0];\n\n        // Note: mutative. If we're stealing a key,\n        // it means this node was created during\n        // the edit and can be mutated.\n        this.keys = this.keys.concat(stolenKey);\n        this.children = this.children.concat(stolenValue);\n\n        const siblingWithoutFirstKey = rightSibling.tail(ownerID);\n        return [this, siblingWithoutFirstKey];\n    },\n\n    giveLastKeyTo(ownerID, rightSibling) {\n        const keyToGive = this.keys[this.keys.length - 1];\n        const valueToGive = this.children[this.children.length - 1];\n\n        // Note: mutative. If we're giving a key,\n        // it means the sibling node was created during\n        // the edit and can be mutated.\n        rightSibling.keys = unshift(ownerID, keyToGive, rightSibling.keys);\n        rightSibling.children = unshift(ownerID, valueToGive, rightSibling.children);\n\n        const thisWithoutLastKey = this.init(ownerID);\n        return [thisWithoutLastKey, rightSibling];\n    },\n});\n\nfunction InternalNode(opts) {\n    Node.call(this, opts);\n}\n\n\nconst REPLACE = 'REPLACE';\nconst STEAL_KEY_FROM_LEFT = 'STEAL_KEY_FROM_LEFT';\nconst STEAL_KEY_FROM_RIGHT = 'STEAL_KEY_FROM_RIGHT';\nconst MERGE = 'MERGE';\n\nexport const DELETION_STRATEGIES = {\n    STEAL_KEY_FROM_LEFT,\n    STEAL_KEY_FROM_RIGHT,\n    MERGE,\n};\n\nInternalNode.prototype = Object.create(Node.prototype);\nInternalNode.prototype.constructor = InternalNode;\n\nextend(InternalNode.prototype, {\n    maxChildren: INTERNAL_MAX_CHILDREN,\n\n    minChildren: INTERNAL_MIN_CHILDREN,\n\n    merge(otherNode) {\n        // We have ak + bk keys, and ac + bc children.\n        // In a node, ac - ak === 1 (one less key than children).\n        // Because (ac + bc) - (ak + bk) === 2, we need to add a key.\n        // The key is the smallest key on the right node subtree.\n        const toConcat = unshift(null, otherNode.smallestKey(), otherNode.keys);\n        const newNode = new InternalNode({\n            order: this.order,\n            keys: this.keys.concat(toConcat),\n            children: this.children.concat(otherNode.children),\n        });\n        return newNode;\n    },\n\n    chooseComplexDeletionStrategy(childIdx, newChild) {\n        // When we need to merge, steal or give keys to\n        // siblings -- this method returns the operation parameters,\n        // which are: the left node, the right node, the index of\n        // the left node in this nodes `children` array, and the\n        // strategy to use (merge, steal from right, steal from left).\n\n        if (newChild.satisfiesMinChildren()) {\n            return {\n                strategy: REPLACE,\n            };\n        }\n\n        const hasRightSibling = childIdx + 1 < this.children.length;\n        const hasLeftSibling = childIdx - 1 >= 0;\n\n        const isLeaf = newChild.constructor === Leaf;\n\n        const nullSibling = { size: 0 };\n\n        const rightSibling = hasRightSibling\n            ? this.children[childIdx + 1]\n            : nullSibling;\n\n        const leftSibling = hasLeftSibling\n            ? this.children[childIdx - 1]\n            : nullSibling;\n\n        const minChildren = isLeaf\n            ? LEAF_MIN_CHILDREN\n            : INTERNAL_MIN_CHILDREN;\n\n        let strategy;\n        if (rightSibling.size >= leftSibling.size) {\n            if (rightSibling.size <= minChildren) {\n                strategy = MERGE;\n            } else {\n                strategy = STEAL_KEY_FROM_RIGHT;\n            }\n\n            return {\n                leftNode: newChild,\n                rightNode: rightSibling,\n                leftNodeIdx: childIdx,\n                strategy,\n            };\n        } else {\n            if (leftSibling.size <= minChildren) {\n                strategy = MERGE;\n            } else {\n                strategy = STEAL_KEY_FROM_LEFT;\n            }\n            return {\n                leftNode: leftSibling,\n                rightNode: newChild,\n                leftNodeIdx: childIdx - 1,\n                strategy,\n            };\n        }\n    },\n\n    delete(cmp, ownerID, didChange, key) {\n        const childIdx = this.childIdxForKey(cmp, key);\n        const origChild = this.children[childIdx];\n        const child = origChild.delete(cmp, ownerID, didChange, key);\n\n        if (!isSet(didChange)) return this;\n\n        const strategyInfo = this.chooseComplexDeletionStrategy(childIdx, child);\n        const strategy = strategyInfo.strategy;\n\n        if (strategy === REPLACE) {\n            return this.withReplacedChildren(ownerID, childIdx, [child]);\n        }\n\n        const {\n            leftNode,\n            rightNode,\n            leftNodeIdx,\n        } = strategyInfo;\n\n        if (strategy === MERGE) {\n            return this.withMergedChildren(ownerID, leftNodeIdx, leftNode, rightNode);\n        }\n\n        let newLeftNode;\n        let newRightNode;\n        if (strategy === STEAL_KEY_FROM_RIGHT) {\n            const newNodes = leftNode.stealFirstKeyFrom(ownerID, rightNode);\n            newLeftNode = newNodes[0];\n            newRightNode = newNodes[1];\n        } else if (strategy === STEAL_KEY_FROM_LEFT) {\n            const newNodes = leftNode.giveLastKeyTo(ownerID, rightNode);\n            newLeftNode = newNodes[0];\n            newRightNode = newNodes[1];\n        }\n\n        const withReplacedChildren = this.withReplacedChildren(\n            ownerID,\n            leftNodeIdx,\n            [newLeftNode, newRightNode]\n        );\n\n        // Key must be updated because of the child key theft.\n        const keyIdxToReplace = leftNodeIdx;\n        const newKey = newRightNode.smallestKey();\n\n        withReplacedChildren.keys = set(\n            ownerID,\n            keyIdxToReplace,\n            newKey,\n            withReplacedChildren.keys\n        );\n        return withReplacedChildren;\n    },\n\n    withMergedChildren(ownerID, leftChildIdx, leftNode, rightNode) {\n        const mergedChild = leftNode.merge(rightNode);\n\n        const keyIdxToPop = leftChildIdx;\n\n        const newKeys = withoutIdx(ownerID, keyIdxToPop, this.keys);\n\n        const areLeftmostNodes = leftChildIdx === 0;\n\n        if (!areLeftmostNodes) {\n            newKeys[leftChildIdx - 1] = mergedChild.smallestKey();\n        }\n\n        const newChildren = arrayClone(this.children);\n        newChildren.splice(leftChildIdx, 1);\n        newChildren[leftChildIdx] = mergedChild;\n\n        const withReplacedChild = new InternalNode({\n            order: this.order,\n            keys: newKeys,\n            children: newChildren,\n            ownerID,\n        });\n        return withReplacedChild;\n    },\n\n    childIdxForKey(cmp, key) {\n        return binarySearch.lte(this.keys, key, cmp) + 1;\n    },\n\n    stealFirstKeyFrom(ownerID, rightSibling) {\n        // Note that we mutate `this`.\n        // Whenever we're stealing a first key,\n        // it means this node was created during\n        // the current update and can be mutated.\n        const stolenValue = rightSibling.children[0];\n\n        this.keys = this.keys.concat(rightSibling.smallestKey());\n        this.children = this.children.concat(stolenValue);\n\n        return [this, rightSibling.tail(ownerID)];\n    },\n\n    giveLastKeyTo(ownerID, rightSibling) {\n        // Steal last key-value pair from left node\n        const stolenValue = last(this.children);\n        rightSibling.keys = unshift(ownerID, rightSibling.smallestKey(), rightSibling.keys);\n        rightSibling.children = unshift(ownerID, stolenValue, rightSibling.children);\n\n        return [this.init(ownerID), rightSibling];\n    },\n\n    withReplacedChildren(ownerID, idx, newChildren) {\n        const replaced = canMutate(this.children, ownerID)\n            ? this.children\n            : arrayClone(this.children);\n\n        for (let i = 0; i < newChildren.length; i++) {\n            replaced[idx + i] = newChildren[i];\n        }\n\n        if (canMutate(this, ownerID)) {\n            this.children = replaced;\n            return this;\n        }\n\n        return new InternalNode({\n            order: this.order,\n            keys: this.keys,\n            children: replaced,\n            ownerID,\n        });\n    },\n\n    smallestKey() {\n        let curr = this;\n        while (curr.constructor !== Leaf) {\n            curr = curr.children[0];\n        }\n        return curr.keys[0];\n    },\n\n    split(ownerID) {\n        const medianIdx = median(this.keys.length) - 1;\n\n        const splitArr = takeIdxAndSplit(ownerID, medianIdx, this.keys);\n        const thisKeys = splitArr[0];\n        const medianKey = splitArr[1];\n        const otherKeys = splitArr[2];\n\n        const childrenPair = splitAt(ownerID, medianIdx + 1, this.children);\n        const thisChildren = childrenPair[0];\n        const otherChildren = childrenPair[1];\n\n        let thisNode;\n        if (canMutate(this, ownerID)) {\n            thisNode = this;\n            thisNode.keys = thisKeys;\n            thisNode.children = thisChildren;\n        } else {\n            thisNode = new InternalNode({\n                order: this.order,\n                keys: thisKeys,\n                children: thisChildren,\n                ownerID,\n            });\n        }\n\n        const otherNode = new InternalNode({\n            order: this.order,\n            keys: otherKeys,\n            children: otherChildren,\n            ownerID,\n        });\n\n        return [medianKey, thisNode, otherNode];\n    },\n\n    withSplitChild(cmp, ownerID, newKey, splitChild, newChild) {\n        const insertNewKeyAt = internalInsertKeyAt(cmp, newKey, this.keys);\n        const newKeys = insert(ownerID, insertNewKeyAt, newKey, this.keys);\n\n        const newChildren = insert(ownerID, insertNewKeyAt + 1, newChild, this.children);\n        // Replace the original child with the split one.\n        newChildren[insertNewKeyAt] = splitChild;\n\n        if (canMutate(this, ownerID)) {\n            this.keys = newKeys;\n            this.children = newChildren;\n            return this;\n        }\n\n        return new InternalNode({\n            order: this.order,\n            keys: newKeys,\n            children: newChildren,\n            ownerID,\n        });\n    },\n\n    insert(cmp, ownerID, didChange, key, value) {\n        const childIdx = this.childIdxForKey(cmp, key);\n        const child = this.children[childIdx];\n\n        const newChild = child.insert(cmp, ownerID, didChange, key, value);\n\n        if (!isSet(didChange)) return this;\n\n        // Got new child.\n\n        // Child was split on insertion.\n        if (newChild.length === 3) {\n            const splitArr = newChild;\n            const medianKey = splitArr[0];\n            const splitChild = splitArr[1];\n            const _newChild = splitArr[2];\n\n            const withSplitChild = this.withSplitChild(\n                cmp, ownerID, medianKey, splitChild, _newChild);\n            return withSplitChild.shouldSplit()\n                ? withSplitChild.split(ownerID)\n                : withSplitChild;\n        }\n\n        return this.withReplacedChildren(ownerID, childIdx, [newChild]);\n    },\n});\n\nexport {\n    Node,\n    Leaf,\n    InternalNode,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/nodes.js\n **/","export const MIN_ROOT_CHILDREN = 2;\n\n// These numbers are optimized for the Path implementation.\n// With these values we can store paths in the binary representation\n// of an integer - the lowest 30 bits divide to 5 parts of 6 bits each.\n// During range searches and iteration, we check if we've reached the\n// end path at each element. When the path is represented as an integer,\n// we can do a fast integer comparison.\n//\n// 6 bits gives us a range of 2^6 = 64 values for each part.\n// The maximum tree size with these limitations should be more than enough,\n// 64^5 - 1 = 1,073,741,823, that's about 1 billion elements.\nexport const ORDER = 64;\nexport const SHIFT_LEN = 6;\n\nexport const LEAF_MIN_CHILDREN = Math.ceil(ORDER / 2) - 1;\nexport const LEAF_MAX_CHILDREN = ORDER - 1;\nexport const INTERNAL_MIN_CHILDREN = Math.ceil(ORDER / 2);\nexport const INTERNAL_MAX_CHILDREN = ORDER;\n\nexport const ITERATOR_PROPNAME = typeof Symbol === 'function'\n    ? Symbol.iterator\n    : '@@iterator';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants.js\n **/","import {\n    ITERATOR_PROPNAME,\n} from './constants';\n\nexport const median = len => Math.ceil(len / 2);\n\nexport function makeOwnerID() {\n    return {};\n}\n\nexport function tagOwnerID(obj, ownerID) {\n    obj.ownerID = ownerID;\n    return obj;\n}\n\nexport function canMutate(obj, ownerID) {\n    return ownerID && ownerID === obj.ownerID;\n}\n\nfunction allocateArray(ownerID, len) {\n    return tagOwnerID(len ? new Array(len) : [], ownerID);\n}\n\nexport function slice(ownerID, start, end, arr) {\n    const newLen = end - start;\n    if (canMutate(arr, ownerID)) {\n        let removeNFromStart = start;\n        let removeNFromEnd = arr.length - end;\n        while (removeNFromStart--) {\n            arr.shift();\n        }\n        while (removeNFromEnd--) {\n            arr.pop();\n        }\n\n        return arr;\n    }\n\n    const newArr = allocateArray(ownerID, newLen);\n    for (let i = start; i < end; i++) {\n        newArr[i - start] = arr[i];\n    }\n    return newArr;\n}\n\nexport function arrayClone(arr) {\n    const len = arr.length;\n    const copy = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\n\nexport function withoutIdx(ownerID, idx, arr) {\n    const copied = canMutate(arr, ownerID)\n        ? arr\n        : tagOwnerID(arrayClone(arr), ownerID);\n\n    copied.splice(idx, 1);\n    return copied;\n}\n\nexport function insert(ownerID, idx, val, arr) {\n    if (canMutate(arr, ownerID)) {\n        arr.splice(idx, 0, val);\n        return arr;\n    }\n\n    const newArrLen = arr.length + 1;\n    const newArr = new Array(newArrLen);\n\n    let i = 0;\n    for (; i < idx; i++) {\n        newArr[i] = arr[i];\n    }\n\n    newArr[i++] = val;\n\n    for (; i < newArrLen; i++) {\n        newArr[i] = arr[i - 1];\n    }\n\n    return newArr;\n}\n\nexport function set(ownerID, idx, val, arr) {\n    const copied = canMutate(arr, ownerID)\n        ? arr\n        : tagOwnerID(arrayClone(arr), ownerID);\n\n    copied[idx] = val;\n    return copied;\n}\n\nexport function fastMap(fn, arr) {\n    const copied = arrayClone(arr);\n    const len = arr.length;\n    for (let i = 0; i < len; i++) {\n        copied[i] = fn(arr[i], i);\n    }\n    return copied;\n}\n\nexport function splitAt(ownerID, idx, arr) {\n    const arrLen = arr.length;\n    const firstArrLen = idx;\n    const secondArrLen = arrLen - idx;\n    const secondArr = allocateArray(ownerID, secondArrLen);\n\n    const firstArr = allocateArray(ownerID, firstArrLen);\n\n    for (let i = 0; i < idx; i++) {\n        firstArr[i] = arr[i];\n    }\n\n    for (let i = idx; i < arrLen; i++) {\n        secondArr[i - idx] = arr[i];\n    }\n\n    return [firstArr, secondArr];\n}\n\nexport function unshift(ownerID, value, arr) {\n    return insert(ownerID, 0, value, arr);\n}\n\nexport const takeIdxAndSplit = (ownerID, idx, arr) => {\n    const cutoff = idx;\n    const a1len = cutoff;\n    const arr1 = slice(ownerID, 0, a1len, arr);\n    const arr2 = slice(ownerID, cutoff + 1, arr.length, arr);\n    return [arr1, arr[cutoff], arr2];\n};\n\nexport function last(arr) {\n    return arr[arr.length - 1];\n}\n\nexport function init(ownerID, arr) {\n    if (canMutate(arr, ownerID)) {\n        if (arr.length === 0) return arr;\n        arr.pop();\n        return arr;\n    }\n\n    if (arr.length <= 1) return allocateArray(ownerID);\n    return slice(ownerID, 0, arr.length - 1, arr);\n}\n\nexport function tail(ownerID, arr) {\n    if (canMutate(arr, ownerID)) {\n        arr.shift();\n        return arr;\n    }\n\n    if (arr.length <= 1) return tagOwnerID([], ownerID);\n    return slice(ownerID, 1, arr.length, arr);\n}\n\nexport function getEmptyIterator() {\n    const iterator = {\n        next: () => ({ done: true }),\n    };\n\n    iterator[ITERATOR_PROPNAME] = () => iterator;\n\n    return iterator;\n}\n\nexport const boundedChunk = (min, max, arr) => {\n    const arrLen = arr.length;\n    if (!arr.length) return [];\n    if (arr.length <= max) {\n        return [arr];\n    }\n\n    const avg = Math.ceil((min + max) / 2);\n    const parts = arrLen / avg;\n    const chunkCount = Math.ceil(parts);\n    const splitsize = (1 / chunkCount) * arrLen;\n    const chunks = new Array(chunkCount);\n    for (let i = 0; i < chunkCount; i++) {\n        chunks[i] = arr.slice(Math.ceil(i * splitsize), Math.ceil((i + 1) * splitsize));\n    }\n    return chunks;\n};\n\nexport function extend(target) {\n    const argsLen = arguments.length;\n    let source;\n    let keys;\n    let key;\n    let i;\n    let j;\n\n    for (j = 1; j < argsLen; j++) {\n        source = arguments[j];\n        keys = Object.keys(source);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\nexport function makeRef(value) {\n    return { value };\n}\n\nexport function setRef(ref) {\n    ref.value = true;\n}\n\nexport function isSet(ref) {\n    return !!ref.value;\n}\n\nexport function normalizeRangeSpec(spec) {\n    return {\n        from: spec.from,\n        to: spec.to,\n        fromInclusive: spec.hasOwnProperty('fromInclusive')\n            ? spec.fromInclusive\n            : true,\n        toInclusive: spec.hasOwnProperty('toInclusive')\n            ? spec.toInclusive\n            : true,\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","import {\n    SHIFT_LEN,\n} from './constants';\nimport {\n    extend,\n} from './utils';\n\nconst MIN_PATH = 0;\nconst NUMBER_OF_UNSIGNED_BITS = 31;\n\nexport const LEVELS = Math.floor(NUMBER_OF_UNSIGNED_BITS / SHIFT_LEN);\n\n/**\n * Slices a range of bits from the binary\n * representation of a number.\n *\n * Example:\n *     num: decimal 376 = binary 101111000\n *     fromBit: 3\n *     toBit: 9\n *     Returns decimal 47 = binary 101111\n *\n * @param  {Number} fromBit - bit to start slicing from, inclusive\n * @param  {Number} toBit - bit to stop slicing at, exclusive\n * @param  {Number} num - number to slice\n * @return {Number} sliced number\n */\nexport const bitSlice = (fromBit, toBit, num) => {\n    // toBit exclusive. Mask is from bits 0..toBit - 1.\n    const mask = Math.pow(2, toBit) - 1;\n\n    return (num & mask) >>> fromBit;\n};\n\n/**\n * Gets the path value for a given level.\n *\n * Example:\n *     shiftLen: 6\n *     level: 1\n *     path:  decimal 16518336 = binary 111111 000000 110011 000000\n *     Returns: decimal 51 = 110011\n *\n * @param  {Number} shiftLen - the binary representation length of a single level\n * @param  {Number} level - the level to get a value from, starting at 0\n * @param  {Number} path - input path\n * @return {Number} value for `path` at level `level`\n */\nexport const pathGet = (shiftLen, level, path) =>\n    bitSlice(\n        shiftLen * level,\n        shiftLen * (level + 1),\n        path\n    );\n\n/**\n * Returns a new updated path where the value for a given level is\n * set to `newValue`. The current value of path at the given level must be 0.\n *\n * @param  {Number} shiftLen - the binary representation length of a single level\n * @param  {Number} level - the level to set the value to, starting at 0\n * @param  {Number} path\n * @param  {Number} newValue\n * @return {Number} an updated path\n */\nexport const pathSet = (shiftLen, level, path, newValue) =>\n    path | (newValue << (shiftLen * level));\n\nexport const clearBitRange = (fromBit, toBit, num) => {\n    const rangeLen = toBit - fromBit;\n    const mask = Math.pow(2, rangeLen) - 1;\n    return num & ~(mask << fromBit);\n};\n\n// Safe version of `pathSet` where the current value is cleared before\n// assigning a new value.\nexport const safePathSet = (shiftLen, level, path, newValue) => {\n    const cleared = clearBitRange(\n        shiftLen * level,\n        shiftLen * (level + 1),\n        path\n    );\n    return pathSet(shiftLen, level, cleared, newValue);\n};\n\nfunction Path(shiftLen, levels, path) {\n    this.shiftLen = shiftLen || SHIFT_LEN;\n    this.length = levels || LEVELS;\n    this._path = path || 0;\n}\n\nPath.EMPTY_PATH = new Path(SHIFT_LEN, LEVELS, MIN_PATH);\nPath.from = function from(arr) {\n    const levels = arr.length;\n\n    let path = 0;\n    for (let i = 0; i < levels; i++) {\n        path = pathSet(SHIFT_LEN, i, path, arr[i]);\n    }\n\n    return new Path(SHIFT_LEN, levels, path);\n};\n\nextend(Path.prototype, {\n    get(level) {\n        return pathGet(this.shiftLen, level, this._path);\n    },\n\n    equals(otherPath) {\n        return this._path === otherPath._path;\n    },\n\n    clearAfter(level) {\n        let currLevel = level + 1;\n        let newPath = this;\n        while (currLevel < this.length) {\n            newPath = newPath.set(currLevel, 0);\n            currLevel++;\n        }\n        return newPath;\n    },\n\n    toArray() {\n        const arr = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    },\n\n    compareTo(otherPath) {\n        const a = this._path;\n        const b = otherPath._path;\n        return a === b ? 0 : a < b ? - 1 : 1; // eslint-disable-line no-nested-ternary\n    },\n\n    increment(level) {\n        const newPath = this.set(level, this.get(level) + 1);\n        return newPath.clearAfter(level);\n    },\n\n    decrement(level) {\n        return this.set(level, this.get(level) - 1);\n    },\n\n    set(level, value) {\n        const newPath = safePathSet(this.shiftLen, level, this._path, value);\n        return new Path(this.shiftLen, this.length, newPath);\n    },\n});\n\nexport { Path };\nexport default Path;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/path.js\n **/"],"sourceRoot":""}
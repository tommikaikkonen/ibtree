{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ibtree.min.js","webpack:///webpack/bootstrap 7018d92107faff2ed869","webpack:///./src/index.js","webpack:///./src/binarysearch.js","webpack:///./src/nodes.js","webpack:///./src/constants.js","webpack:///./src/utils.js","webpack:///./src/path.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","BPlusTree","_opts","opts","order","_constants","ORDER","isSet","undefined","extractor","comparator","defaultComparator","_nodes","Leaf","size","height","ownerID","fromSortedBase","isPairs","MIN_ADJUSTMENT","minPageLen","LEAF_MIN_CHILDREN","maxPageLen","LEAF_MAX_CHILDREN","minNodeChildren","INTERNAL_MIN_CHILDREN","maxNodeChildren","INTERNAL_MAX_CHILDREN","pages","_utils","boundedChunk","leafs","fastMap","page","leafKeys","item","leafValues","keys","children","newHeight","newRoot","leafsProcessed","currLevel","_loop","chunked","firstInChunk","nodes","chunk","operation","child","_head","tail","operateOn","newKeys","InternalNode","_ret","_constructor","extend","fromSortedPairs","fromSortedValues","BTSet","Object","defineProperty","value","BTMap","_binarysearch","_binarysearch2","_path","_path2","binSearch","eq","NOT_FOUND","a","b","extractValue","leaf","idx","extractKey","extractEntry","prototype","has","key","search","add","set","get","val","clear","constructor","cmp","extractedKey","didChange","makeRef","result","insert","rootSplit","canMutate","splitArr","medianKey","splitChild","newChild","newRootKeys","tagOwnerID","newRootChildren","newSize","_didAlter","delete","rootMerged","MIN_ROOT_CHILDREN","isLeaf","newTree","asMutable","makeOwnerID","asImmutable","withMutations","fn","mutable","_baseBetween","_rangeSpec","getEmptyIterator","rangeSpec","normalizeRangeSpec","fromKey","toKey","to","isReverse","fromIsRight","toIsRight","fromPath","findPath","fromInclusive","toPath","toInclusive","_iteratorFromTo","between","arguments","spec","_pathNodes","path","curr","_nextPath","level","increment","_prevPath","equals","EMPTY_PATH","newPath","childLen","_iterateAllWithExtractFn","extractFn","_getLeftmostPath","_getRightmostPath","_getLeafFromPath","currNode","keypath","leafLevel","push","SHIFT_LEN","_this","getPathSuccessor","bind","currPath","leafCacheRef","done","iterator","next","pathsEq","valIdx","decrement","ITERATOR_PROPNAME","fromRight","isInclusive","numAccessesToReachLeaf","prev","_idx","childIdxForKey","parent","searchFuncName","searchFunc","hasRightLeaf","hasLeftLeaf","findLeaf","visit","queue","shift","apply","makeIteratorMethod","_spec","values","valueRange","entries","entryRange","keyRange","baseLte","inclusive","array","len","l","r","mid","baseGte","lte","lt","gte","gt","Node","DELETION_STRATEGIES","internalInsertKeyAt","enumerable","satisfiesMinChildren","minChildren","satisfiesMaxChildren","maxChildren","init","shouldSplit","create","setRef","newLeaf","withoutIdx","newChildren","merge","otherLeaf","concat","idxForKey","alreadyHasKey","existingValue","split","cutoff","median","smallestKeyInOther","keypair","splitAt","thisKeys","otherKeys","childrenPair","thisChildren","otherChildren","other","thisSplit","smallestKey","stealFirstKeyFrom","rightSibling","stolenKey","stolenValue","siblingWithoutFirstKey","giveLastKeyTo","keyToGive","valueToGive","unshift","thisWithoutLastKey","REPLACE","STEAL_KEY_FROM_LEFT","STEAL_KEY_FROM_RIGHT","MERGE","otherNode","toConcat","newNode","chooseComplexDeletionStrategy","childIdx","strategy","hasRightSibling","hasLeftSibling","nullSibling","leftSibling","leftNode","rightNode","leftNodeIdx","origChild","strategyInfo","withReplacedChildren","withMergedChildren","newLeftNode","newRightNode","newNodes","_newNodes","keyIdxToReplace","newKey","leftChildIdx","mergedChild","keyIdxToPop","areLeftmostNodes","arrayClone","splice","withReplacedChild","last","replaced","medianIdx","takeIdxAndSplit","thisNode","withSplitChild","insertNewKeyAt","_newChild","Math","ceil","Symbol","allocateArray","slice","start","end","newLen","removeNFromStart","removeNFromEnd","pop","newArr","copy","copied","newArrLen","arrLen","firstArrLen","secondArrLen","secondArr","firstArr","_i","target","argsLen","source","j","ref","hasOwnProperty","a1len","arr1","min","max","avg","parts","chunkCount","splitsize","chunks","Path","shiftLen","levels","LEVELS","safePathSet","clearBitRange","pathSet","pathGet","bitSlice","MIN_PATH","NUMBER_OF_UNSIGNED_BITS","floor","fromBit","toBit","num","mask","pow","newValue","rangeLen","cleared","otherPath","clearAfter","toArray","compareTo"],"mappings":"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","file":"ibtree.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ibtree\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ibtree\"] = factory();\n\telse\n\t\troot[\"ibtree\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ibtree\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ibtree\"] = factory();\n\telse\n\t\troot[\"ibtree\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.BTMap = exports.defaultComparator = undefined;\n\texports.BPlusTree = BPlusTree;\n\texports.BTSet = BTSet;\n\t\n\tvar _binarysearch = __webpack_require__(1);\n\t\n\tvar _binarysearch2 = _interopRequireDefault(_binarysearch);\n\t\n\tvar _nodes = __webpack_require__(2);\n\t\n\tvar _path = __webpack_require__(5);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar binSearch = _binarysearch2.default.eq;\n\t\n\tvar NOT_FOUND = {};\n\t\n\tvar defaultComparator = exports.defaultComparator = function defaultComparator(a, b) {\n\t    return (// eslint-disable-line no-confusing-arrow\n\t        a === b // eslint-disable-line no-nested-ternary\n\t        ? 0 : a < b ? -1 : 1\n\t    );\n\t};\n\t\n\t// Iterator extraction funcs\n\t\n\tvar extractValue = function extractValue(leaf, idx) {\n\t    return leaf.children[idx];\n\t};\n\tvar extractKey = function extractKey(leaf, idx) {\n\t    return leaf.keys[idx];\n\t};\n\tvar extractEntry = function extractEntry(leaf, idx) {\n\t    return [extractKey(leaf, idx), extractValue(leaf, idx)];\n\t};\n\t\n\tfunction BPlusTree(_opts) {\n\t    var opts = _opts || {};\n\t    this.order = _constants.ORDER;\n\t\n\t    // Used to decide whether @@iterator returns\n\t    // values or entries.\n\t    this.isSet = opts.isSet === undefined ? false : opts.isSet;\n\t\n\t    this.extractor = opts.extractor; // May be undefined on purpose.\n\t    this.comparator = opts.comparator || defaultComparator;\n\t\n\t    this.root = opts.root || new _nodes.Leaf({ order: this.order });\n\t    this.size = opts.size || 0;\n\t    this.height = opts.height || 0;\n\t    this.ownerID = opts.ownerID;\n\t}\n\t\n\t(0, _utils.extend)(BPlusTree.prototype, {\n\t    has: function has(key) {\n\t        return this.search(this.comparator, key) !== NOT_FOUND;\n\t    },\n\t    add: function add(value) {\n\t        return this.set(value, value);\n\t    },\n\t    get: function get(key) {\n\t        var val = this.search(this.comparator, key);\n\t        return val === NOT_FOUND ? undefined : val;\n\t    },\n\t    clear: function clear() {\n\t        return new this.constructor({\n\t            comparator: this.comparator,\n\t            extractor: this.extractor\n\t        });\n\t    },\n\t    set: function set(key, value) {\n\t        var cmp = this.comparator;\n\t        var extractedKey = this.extractor ? this.extractor(key) : key;\n\t\n\t        var didChange = (0, _utils.makeRef)(false);\n\t        var result = this.root.insert(cmp, this.ownerID, didChange, extractedKey, value);\n\t\n\t        if (!(0, _utils.isSet)(didChange)) return this;\n\t\n\t        var newRoot = void 0;\n\t        var rootSplit = false;\n\t        var canMutate = !!this.ownerID;\n\t\n\t        // Root was split\n\t        if (result.length === 3) {\n\t            rootSplit = true;\n\t            var splitArr = result;\n\t            var medianKey = splitArr[0];\n\t            var splitChild = splitArr[1];\n\t            var newChild = splitArr[2];\n\t\n\t            var newRootKeys = (0, _utils.tagOwnerID)([medianKey], this.ownerID);\n\t            var newRootChildren = (0, _utils.tagOwnerID)([splitChild, newChild], this.ownerID);\n\t\n\t            newRoot = new _nodes.InternalNode({\n\t                order: this.order,\n\t                keys: newRootKeys,\n\t                children: newRootChildren\n\t            });\n\t        } else {\n\t            newRoot = result;\n\t        }\n\t\n\t        var newHeight = rootSplit ? this.height + 1 : this.height;\n\t        var newSize = this.size + 1;\n\t\n\t        if (canMutate) {\n\t            this.height = newHeight;\n\t            this.size = newSize;\n\t            this.root = newRoot;\n\t            this._didAlter = true;\n\t            return this;\n\t        }\n\t        return new this.constructor({\n\t            extractor: this.extractor,\n\t            comparator: this.comparator,\n\t            root: newRoot,\n\t            height: newHeight,\n\t            size: newSize,\n\t            ownerID: this.ownerID\n\t        });\n\t    },\n\t    delete: function _delete(key) {\n\t        var didChange = (0, _utils.makeRef)(false);\n\t        var newRoot = this.root.delete(this.comparator, this.ownerID, didChange, key);\n\t\n\t        if (!(0, _utils.isSet)(didChange)) return this;\n\t\n\t        var rootMerged = false;\n\t        if (newRoot.size < _constants.MIN_ROOT_CHILDREN) {\n\t            var isLeaf = newRoot.constructor === _nodes.Leaf;\n\t            if (!isLeaf) {\n\t                // Since the minimum number of children in\n\t                // the root is 2, the root must have a single\n\t                // child.\n\t                newRoot = newRoot.children[0];\n\t                rootMerged = true;\n\t            }\n\t            // If the root is a leaf, it can be empty.\n\t        }\n\t\n\t        var canMutate = !!this.ownerID;\n\t\n\t        var newTree = void 0;\n\t        var newHeight = rootMerged ? this.height - 1 : this.height;\n\t        var newSize = this.size - 1;\n\t\n\t        if (canMutate) {\n\t            newTree = this;\n\t            this.root = newRoot;\n\t            this.height = newHeight;\n\t            this.size = newSize;\n\t            this._didAlter = true;\n\t        } else {\n\t            newTree = new this.constructor({\n\t                comparator: this.comparator,\n\t                extractor: this.extractor,\n\t                root: newRoot,\n\t                height: newHeight,\n\t                size: newSize,\n\t                ownerID: this.ownerID\n\t            });\n\t        }\n\t        return newTree;\n\t    },\n\t    asMutable: function asMutable() {\n\t        return this.ownerID ? this : new this.constructor({\n\t            comparator: this.comparator,\n\t            extractor: this.extractor,\n\t            root: this.root,\n\t            height: this.height,\n\t            size: this.size,\n\t            ownerID: (0, _utils.makeOwnerID)()\n\t        });\n\t    },\n\t    asImmutable: function asImmutable() {\n\t        return this.ownerID ? new this.constructor({\n\t            comparator: this.comparator,\n\t            extractor: this.extractor,\n\t            root: this.root,\n\t            height: this.height,\n\t            size: this.size\n\t        }) : this;\n\t    },\n\t    withMutations: function withMutations(fn) {\n\t        var mutable = this.asMutable();\n\t        fn(mutable);\n\t        return mutable._didAlter ? mutable.asImmutable() : this;\n\t    },\n\t    _baseBetween: function _baseBetween(extractor, _rangeSpec) {\n\t        if (this.size === 0) return (0, _utils.getEmptyIterator)();\n\t\n\t        var rangeSpec = (0, _utils.normalizeRangeSpec)(_rangeSpec);\n\t\n\t        var fromKey = this.extractor ? this.extractor(rangeSpec.from) : rangeSpec.from;\n\t\n\t        var toKey = this.extractor ? this.extractor(rangeSpec.to) : rangeSpec.to;\n\t\n\t        var isReverse = this.comparator(fromKey, toKey) > 0;\n\t\n\t        var fromIsRight = isReverse;\n\t        var toIsRight = !fromIsRight;\n\t\n\t        var fromPath = this.findPath(fromKey, fromIsRight, rangeSpec.fromInclusive);\n\t        var toPath = this.findPath(toKey, toIsRight, rangeSpec.toInclusive);\n\t\n\t        if (fromPath === null || toPath === null) {\n\t            return (0, _utils.getEmptyIterator)();\n\t        }\n\t\n\t        return this._iteratorFromTo(extractor, fromPath, toPath, isReverse);\n\t    },\n\t    between: function between(fromKey, toKey) {\n\t        if (arguments.length === 1) {\n\t            var rangeSpec = arguments[0];\n\t            return this._baseBetween(extractEntry, rangeSpec);\n\t        }\n\t\n\t        var spec = {\n\t            from: fromKey,\n\t            to: toKey\n\t        };\n\t\n\t        return this._baseBetween(extractEntry, spec);\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns the internal and leaf nodes\n\t     * on the path from root to value.\n\t     *\n\t     * @param  {Path} path\n\t     * @return {Array[Node]}\n\t     */\n\t    _pathNodes: function _pathNodes(path) {\n\t        var nodes = new Array(path.length);\n\t\n\t        var curr = this.root;\n\t        for (var i = 0; i < path.length; i++) {\n\t            nodes[i] = curr;\n\t            curr = curr.children[path.get(i)];\n\t        }\n\t\n\t        return nodes;\n\t    },\n\t    _nextPath: function _nextPath(path) {\n\t        var nodes = this._pathNodes(path);\n\t        var level = nodes.length - 1;\n\t\n\t        // Simple case: leaf index can be incremented.\n\t        if (path.get(level) < nodes[level].children.length - 1) {\n\t            return path.increment(level);\n\t        }\n\t\n\t        level--;\n\t        // Go through the node path starting from the lowest internal node and\n\t        // find the first node we can increment a key for.\n\t        while (level >= 0 && path.get(level) === nodes[level].children.length - 1) {\n\t            level--;\n\t        } // All nodes were at their maximum key\n\t        if (level < 0) return null;\n\t        return path.increment(level);\n\t    },\n\t    _prevPath: function _prevPath(path) {\n\t        // Leftmost path - can't decrement.\n\t        if (path.equals(_path2.default.EMPTY_PATH)) return null;\n\t\n\t        var nodes = this._pathNodes(path);\n\t\n\t        var level = path.length - 1;\n\t        while (path.get(level) === 0) {\n\t            level--;\n\t        }var newPath = path.set(level, path.get(level) - 1);\n\t\n\t        // Set all the lower keys to their\n\t        // maximum value.\n\t        var curr = nodes[level].children[newPath.get(level)];\n\t        level++;\n\t        for (; level < path.length; level++) {\n\t            var childLen = curr.children.length;\n\t            newPath = newPath.set(level, childLen - 1);\n\t            curr = curr.children[childLen - 1];\n\t        }\n\t        return newPath;\n\t    },\n\t    _iterateAllWithExtractFn: function _iterateAllWithExtractFn(extractFn) {\n\t        if (this.size === 0) return (0, _utils.getEmptyIterator)();\n\t\n\t        return this._iteratorFromTo(extractFn, this._getLeftmostPath(), this._getRightmostPath());\n\t    },\n\t    _getLeafFromPath: function _getLeafFromPath(path) {\n\t        var level = this.height;\n\t\n\t        var currLevel = 0;\n\t        var currNode = this.root;\n\t\n\t        while (currLevel !== level) {\n\t            currNode = currNode.children[path.get(currLevel++)];\n\t        }\n\t        return currNode;\n\t    },\n\t    _getRightmostPath: function _getRightmostPath() {\n\t        if (this.size === 0) return null;\n\t\n\t        var keypath = [];\n\t        var curr = this.root;\n\t        var currLevel = 0;\n\t        var leafLevel = this.height;\n\t\n\t        while (currLevel !== leafLevel + 1) {\n\t            var idx = curr.children.length - 1;\n\t            keypath.push(idx);\n\t            curr = curr.children[idx];\n\t            currLevel++;\n\t        }\n\t        return _path2.default.from(keypath);\n\t    },\n\t    _getLeftmostPath: function _getLeftmostPath() {\n\t        if (this.size === 0) {\n\t            return null;\n\t        }\n\t\n\t        return new _path2.default(_constants.SHIFT_LEN, this.height + 1);\n\t    },\n\t    _iteratorFromTo: function _iteratorFromTo(extractFn, fromPath, toPath, isReverse) {\n\t        var _this = this;\n\t\n\t        var getPathSuccessor = isReverse ? this._prevPath.bind(this) : this._nextPath.bind(this);\n\t\n\t        var leafLevel = this.height;\n\t\n\t        var currPath = fromPath;\n\t\n\t        // Most of the time we're just getting the next\n\t        // value from a leaf, so it makes sense to cache\n\t        // the leaf instead of looking up the successor\n\t        // path each time.\n\t        var leafCacheRef = void 0;\n\t        var done = false;\n\t        var iterator = {\n\t            next: function next() {\n\t                var pathsEq = currPath !== null && currPath.equals(toPath);\n\t                if (currPath !== null && (!pathsEq || !done)) {\n\t                    var valIdx = currPath.get(leafLevel);\n\t                    var leaf = leafCacheRef || _this._getLeafFromPath(currPath);\n\t                    if (!pathsEq) {\n\t                        if (isReverse && valIdx > 0) {\n\t                            // Can decrement leaf index\n\t                            currPath = currPath.decrement(leafLevel);\n\t                        } else if (!isReverse && valIdx < leaf.children.length - 1) {\n\t                            // Can increment leaf idx\n\t                            currPath = currPath.increment(leafLevel);\n\t                        } else {\n\t                            currPath = getPathSuccessor(currPath);\n\t                            leafCacheRef = undefined;\n\t                        }\n\t                    } else {\n\t                        done = true;\n\t                    }\n\t\n\t                    var value = extractFn(leaf, valIdx);\n\t\n\t                    return {\n\t                        value: value\n\t                    };\n\t                }\n\t\n\t                return {\n\t                    done: true\n\t                };\n\t            }\n\t        };\n\t\n\t        iterator[_constants.ITERATOR_PROPNAME] = function () {\n\t            return iterator;\n\t        };\n\t\n\t        return iterator;\n\t    },\n\t    findPath: function findPath(key, fromRight, isInclusive) {\n\t        if (this.size === 0) return null;\n\t\n\t        var cmp = this.comparator;\n\t\n\t        var curr = this.root;\n\t        var numAccessesToReachLeaf = this.height;\n\t\n\t        // Path needs one more value (which key to look up in leaf)\n\t        var keypath = new Array(numAccessesToReachLeaf + 1);\n\t\n\t        var i = 0;\n\t        var prev = curr;\n\t        for (; i < numAccessesToReachLeaf; i++) {\n\t            var _idx = curr.childIdxForKey(cmp, key);\n\t            keypath[i] = _idx;\n\t            prev = curr;\n\t            curr = curr.children[_idx];\n\t        }\n\t\n\t        var parent = prev;\n\t\n\t        var searchFuncName = (fromRight ? 'lt' : 'gt') + (isInclusive ? 'e' : '');\n\t        var searchFunc = _binarysearch2.default[searchFuncName];\n\t\n\t        // curr should be a leaf now.\n\t        var idx = searchFunc(curr.keys, key, cmp);\n\t\n\t        if (idx === curr.keys.length) {\n\t            if (!fromRight) {\n\t                // The key we're looking for could be in the right leaf.\n\t                keypath[i - 1]++;\n\t\n\t                var hasRightLeaf = keypath[i - 1] < parent.children.length;\n\t                if (!hasRightLeaf) return null;\n\t                curr = parent.children[keypath[i - 1]];\n\t                if (curr.keys[0] >= key) {\n\t                    keypath[i] = 0;\n\t                } else {\n\t                    // out of bounds.\n\t                    return null;\n\t                }\n\t            } else {\n\t                keypath[i] = idx - 1;\n\t            }\n\t        } else if (idx === -1) {\n\t            if (fromRight) {\n\t                // the key we're looking for could be in the left leaf.\n\t                keypath[i - 1]--;\n\t\n\t                var hasLeftLeaf = keypath[i - 1] >= 0;\n\t                if (!hasLeftLeaf) return null;\n\t\n\t                curr = parent.children[keypath[i - 1]];\n\t                if (curr.keys[curr.keys.length - 1] <= key) {\n\t                    keypath[i] = curr.keys.length - 1;\n\t                } else {\n\t                    // out of bounds.\n\t                    return null;\n\t                }\n\t            } else {\n\t                keypath[i] = 0;\n\t            }\n\t        } else {\n\t            keypath[i] = idx;\n\t        }\n\t\n\t        return _path2.default.from(keypath);\n\t    },\n\t    findLeaf: function findLeaf(cmp, key) {\n\t        var curr = this.root;\n\t        var numAccessesToReachLeaf = this.height;\n\t        for (var i = 0; i < numAccessesToReachLeaf; i++) {\n\t            var idx = curr.childIdxForKey(cmp, key);\n\t            curr = curr.children[idx];\n\t        }\n\t\n\t        return curr;\n\t    },\n\t    search: function search(cmp, key) {\n\t        var extractedKey = this.extractor ? this.extractor(key) : key;\n\t\n\t        var leaf = this.findLeaf(cmp, extractedKey);\n\t        var idx = binSearch(leaf.keys, extractedKey, cmp);\n\t        if (idx === -1) {\n\t            return NOT_FOUND;\n\t        }\n\t\n\t        return leaf.children[idx];\n\t    },\n\t    visit: function visit(fn) {\n\t        var queue = [this.root];\n\t        while (queue.length) {\n\t            var curr = queue.shift();\n\t            fn(curr);\n\t            if (curr.constructor !== _nodes.Leaf && curr.children) {\n\t                queue.push.apply(queue, _toConsumableArray(curr.children));\n\t            }\n\t        }\n\t    }\n\t});\n\t\n\tvar makeIteratorMethod = function makeIteratorMethod(extractor) {\n\t    return function getRangeIterator() {\n\t        if (arguments.length === 0) {\n\t            return this._iterateAllWithExtractFn(extractor);\n\t        } else if (arguments.length === 1) {\n\t            var _spec = arguments[0];\n\t            this._baseBetween(extractor, _spec);\n\t        }\n\t\n\t        var spec = {\n\t            from: arguments[0],\n\t            to: arguments[1]\n\t        };\n\t\n\t        return this._baseBetween(extractor, spec);\n\t    };\n\t};\n\t\n\tBPlusTree.prototype.values = makeIteratorMethod(extractValue);\n\tBPlusTree.prototype.valueRange = BPlusTree.prototype.values;\n\tBPlusTree.prototype.entries = makeIteratorMethod(extractEntry);\n\tBPlusTree.prototype.entryRange = BPlusTree.prototype.entries;\n\tBPlusTree.prototype.keys = makeIteratorMethod(extractKey);\n\tBPlusTree.prototype.keyRange = BPlusTree.prototype.keys;\n\t\n\tfunction fromSortedBase(arr, _opts, isPairs) {\n\t    var opts = _opts || {};\n\t\n\t    var order = _constants.ORDER;\n\t\n\t    // For leftmost nodes, we don't take a key\n\t    // to their parent. That means the parent\n\t    // could have one too few children, if it's\n\t    // already at minimum. This adjusts for that.\n\t    var MIN_ADJUSTMENT = 1;\n\t\n\t    var minPageLen = _constants.LEAF_MIN_CHILDREN + MIN_ADJUSTMENT;\n\t    var maxPageLen = _constants.LEAF_MAX_CHILDREN;\n\t\n\t    var minNodeChildren = _constants.INTERNAL_MIN_CHILDREN;\n\t    var maxNodeChildren = _constants.INTERNAL_MAX_CHILDREN;\n\t\n\t    var pages = (0, _utils.boundedChunk)(minPageLen, maxPageLen, arr);\n\t\n\t    var leafs = (0, _utils.fastMap)(function (page) {\n\t        var leafKeys = void 0;\n\t        if (isPairs) {\n\t            leafKeys = (0, _utils.fastMap)(function (item) {\n\t                return opts.extractor ? opts.extractor(item[0]) : item[0];\n\t            }, page);\n\t        } else {\n\t            leafKeys = opts.extractor ? (0, _utils.fastMap)(opts.extractor, page) : page;\n\t        }\n\t\n\t        var leafValues = isPairs ? (0, _utils.fastMap)(function (item) {\n\t            return item[1];\n\t        }, page) : page;\n\t\n\t        return new _nodes.Leaf({\n\t            order: order,\n\t            keys: leafKeys,\n\t            children: leafValues\n\t        });\n\t    }, pages);\n\t\n\t    var newHeight = 0;\n\t    var newRoot = null;\n\t    var leafsProcessed = false;\n\t    if (leafs.length === 1) {\n\t        newRoot = leafs[0];\n\t    } else {\n\t        var currLevel = leafs;\n\t\n\t        var _loop = function _loop() {\n\t            var chunked = (0, _utils.boundedChunk)(minNodeChildren + MIN_ADJUSTMENT, maxNodeChildren, currLevel);\n\t            var firstInChunk = true;\n\t            var nodes = (0, _utils.fastMap)(function (chunk) {\n\t                // eslint-disable-line\n\t                // For leafs, we use the first key as the key\n\t                // for the whole chunk.\n\t                // For internal nodes, we move the first\n\t                // key up a level.\n\t                var operation = leafsProcessed ? function (child) {\n\t                    var _head = child.keys[0];\n\t                    child.keys = (0, _utils.tail)(null, child.keys); // eslint-disable-line\n\t                    return _head;\n\t                } : function (child) {\n\t                    return child.keys[0];\n\t                };\n\t\n\t                // For the left-most nodes, we don't\n\t                // take a key from its children.\n\t                var operateOn = firstInChunk ? (0, _utils.tail)(null, chunk) : chunk;\n\t\n\t                var newKeys = (0, _utils.fastMap)(operation, operateOn);\n\t\n\t                firstInChunk = false;\n\t                return new _nodes.InternalNode({\n\t                    order: order,\n\t                    keys: newKeys,\n\t                    children: chunk\n\t                });\n\t            }, chunked);\n\t\n\t            if (nodes.length === 0) return 'break';\n\t            currLevel = nodes;\n\t            leafsProcessed = true;\n\t            newHeight++;\n\t        };\n\t\n\t        while (currLevel.length > 1) {\n\t            var _ret = _loop();\n\t\n\t            if (_ret === 'break') break;\n\t        }\n\t\n\t        newRoot = currLevel[0];\n\t    }\n\t\n\t    var _constructor = this;\n\t    return new _constructor((0, _utils.extend)({}, opts, {\n\t        root: newRoot,\n\t        size: arr.length,\n\t        height: newHeight\n\t    }));\n\t}\n\t\n\tfunction fromSortedPairs(arr, opts) {\n\t    return fromSortedBase.call(this, arr, opts, true);\n\t}\n\t\n\tfunction fromSortedValues(arr, opts) {\n\t    return fromSortedBase.call(this, arr, opts, false);\n\t}\n\t\n\tBPlusTree.from = fromSortedPairs;\n\t\n\tBPlusTree.prototype[_constants.ITERATOR_PROPNAME] = function iterator() {\n\t    return this.isSet ? this.values() : this.entries();\n\t};\n\t\n\tvar BTMap = exports.BTMap = BPlusTree;\n\t\n\tfunction BTSet(_opts) {\n\t    var opts = _opts || {};\n\t    opts.isSet = true;\n\t    BPlusTree.call(this, opts);\n\t}\n\t\n\tBTSet.from = fromSortedValues;\n\t\n\tBTSet.prototype = BPlusTree.prototype;\n\t\n\texports.default = BTMap;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.baseGte = baseGte;\n\texports.eq = eq;\n\tfunction baseLte(inclusive, array, value, cmp) {\n\t    var len = array.length;\n\t    if (len === 0 || !(inclusive ? cmp(array[0], value) <= 0 : cmp(array[0], value) < 0)) {\n\t        return -1;\n\t    }\n\t\n\t    var l = 0;\n\t    var r = len;\n\t    while (r - l > 1) {\n\t        // In our case, r + l <= 128 so we don't need\n\t        // to worry about overflow here\n\t        var mid = r + l >>> 1;\n\t        var item = array[mid];\n\t        if (inclusive ? cmp(item, value) <= 0 : cmp(item, value) < 0) {\n\t            l = mid;\n\t        } else {\n\t            r = mid;\n\t        }\n\t    }\n\t\n\t    return l;\n\t}\n\t\n\tvar lte = exports.lte = baseLte.bind(null, true);\n\tvar lt = exports.lt = baseLte.bind(null, false);\n\t\n\tfunction baseGte(inclusive, array, value, cmp) {\n\t    var len = array.length;\n\t    if (len === 0 || !(inclusive ? cmp(array[len - 1], value) >= 0 : cmp(array[len - 1], value) > 0)) return len;\n\t    var l = -1;\n\t    var r = len - 1;\n\t    while (r - l > 1) {\n\t        var mid = r + l >>> 1;\n\t        var item = array[mid];\n\t        if (inclusive ? cmp(item, value) >= 0 : cmp(item, value) > 0) {\n\t            r = mid;\n\t        } else {\n\t            l = mid;\n\t        }\n\t    }\n\t\n\t    return r;\n\t}\n\t\n\tvar gte = exports.gte = baseGte.bind(null, true);\n\tvar gt = exports.gt = baseGte.bind(null, false);\n\t\n\tfunction eq(array, value, cmp) {\n\t    var idx = lte(array, value, cmp);\n\t    if (idx !== -1 && cmp(array[idx], value) === 0) {\n\t        return idx;\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.default = {\n\t    lt: lt,\n\t    gt: gt,\n\t    lte: lte,\n\t    gte: gte,\n\t    eq: eq\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.InternalNode = exports.Leaf = exports.Node = exports.DELETION_STRATEGIES = undefined;\n\t\n\tvar _binarysearch = __webpack_require__(1);\n\t\n\tvar _binarysearch2 = _interopRequireDefault(_binarysearch);\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar binSearch = _binarysearch2.default.eq;\n\t\n\tvar internalInsertKeyAt = function internalInsertKeyAt(cmp, key, keys) {\n\t    return _binarysearch2.default.gte(keys, key, cmp);\n\t};\n\t\n\tfunction Node(_opts) {\n\t    var opts = _opts || {};\n\t    this.keys = opts.keys || [];\n\t    this.children = opts.children || [];\n\t    this.order = _constants.ORDER;\n\t    this.ownerID = opts.ownerID;\n\t}\n\t\n\tObject.defineProperty(Node.prototype, 'size', {\n\t    enumerable: true,\n\t    get: function get() {\n\t        return this.children.length;\n\t    }\n\t});\n\t\n\t(0, _utils.extend)(Node.prototype, {\n\t    satisfiesMinChildren: function satisfiesMinChildren() {\n\t        return this.children.length >= this.minChildren;\n\t    },\n\t    satisfiesMaxChildren: function satisfiesMaxChildren() {\n\t        return this.children.length <= this.maxChildren;\n\t    },\n\t    tail: function tail(ownerID) {\n\t        return new this.constructor({\n\t            order: this.order,\n\t            keys: (0, _utils.tail)(ownerID, this.keys),\n\t            children: (0, _utils.tail)(ownerID, this.children),\n\t            ownerID: ownerID\n\t        });\n\t    },\n\t    init: function init(ownerID) {\n\t        return new this.constructor({\n\t            order: this.order,\n\t            keys: (0, _utils.init)(ownerID, this.keys),\n\t            children: (0, _utils.init)(ownerID, this.children),\n\t            ownerID: ownerID\n\t        });\n\t    },\n\t    shouldSplit: function shouldSplit() {\n\t        return !this.satisfiesMaxChildren();\n\t    }\n\t});\n\t\n\tfunction Leaf(opts) {\n\t    Node.call(this, opts);\n\t}\n\t\n\tLeaf.prototype = Object.create(Node.prototype);\n\tLeaf.prototype.constructor = Leaf;\n\t\n\t(0, _utils.extend)(Leaf.prototype, {\n\t    maxChildren: _constants.LEAF_MAX_CHILDREN,\n\t\n\t    minChildren: _constants.LEAF_MIN_CHILDREN,\n\t\n\t    delete: function _delete(cmp, ownerID, didChange, key) {\n\t        var idx = binSearch(this.keys, key, cmp);\n\t        // Key was not found. No modifications needed.\n\t        if (idx === -1) {\n\t            return this;\n\t        }\n\t\n\t        (0, _utils.setRef)(didChange);\n\t\n\t        var newLeaf = void 0;\n\t        var newKeys = (0, _utils.withoutIdx)(ownerID, idx, this.keys);\n\t        var newChildren = (0, _utils.withoutIdx)(ownerID, idx, this.children);\n\t\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            newLeaf = this;\n\t            newLeaf.keys = newKeys;\n\t            newLeaf.children = newChildren;\n\t        } else {\n\t            newLeaf = new Leaf({\n\t                order: this.order,\n\t                keys: (0, _utils.withoutIdx)(ownerID, idx, this.keys),\n\t                children: (0, _utils.withoutIdx)(ownerID, idx, this.children),\n\t                ownerID: ownerID\n\t            });\n\t        }\n\t\n\t        return newLeaf;\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns a new leaf with entries merged\n\t     * from `otherLeaf`. The keys in `otherLeaf`\n\t     * must be higher than in the current leaf,\n\t     * i.e. `otherLeaf` must reside to the right of\n\t     * this leaf in the tree.\n\t     * @param  {Leaf} otherLeaf - other leaf to merge\n\t     * @return {Leaf} a new Leaf with entries merged.\n\t     */\n\t    merge: function merge(otherLeaf) {\n\t        return new Leaf({\n\t            order: this.order,\n\t            keys: this.keys.concat(otherLeaf.keys),\n\t            children: this.children.concat(otherLeaf.children)\n\t        });\n\t    },\n\t    idxForKey: function idxForKey(cmp, key) {\n\t        return _binarysearch2.default.gte(this.keys, key, cmp);\n\t    },\n\t    insert: function insert(cmp, ownerID, didChange, key, value) {\n\t        var idx = this.idxForKey(cmp, key);\n\t        var alreadyHasKey = this.keys[idx] === key;\n\t\n\t        var newKeys = void 0;\n\t        var newChildren = void 0;\n\t\n\t        if (!alreadyHasKey) {\n\t            newKeys = (0, _utils.insert)(ownerID, idx, key, this.keys);\n\t            newChildren = (0, _utils.insert)(ownerID, idx, value, this.children);\n\t        } else {\n\t            var existingValue = this.children[idx];\n\t            if (existingValue === value) {\n\t                return this;\n\t            }\n\t\n\t            newKeys = (0, _utils.set)(ownerID, idx, key, this.keys);\n\t            newChildren = (0, _utils.set)(ownerID, idx, value, this.children);\n\t        }\n\t\n\t        (0, _utils.setRef)(didChange);\n\t\n\t        var newLeaf = void 0;\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            newLeaf = this;\n\t            this.keys = newKeys;\n\t            this.children = newChildren;\n\t        } else {\n\t            newLeaf = new Leaf({\n\t                order: this.order,\n\t                keys: newKeys,\n\t                children: newChildren,\n\t                ownerID: ownerID\n\t            });\n\t        }\n\t\n\t        return newLeaf.shouldSplit() ? newLeaf.split(ownerID) : newLeaf;\n\t    },\n\t    split: function split(ownerID) {\n\t        var cutoff = (0, _utils.median)(this.keys.length);\n\t        var smallestKeyInOther = this.keys[cutoff];\n\t\n\t        var keypair = (0, _utils.splitAt)(ownerID, cutoff, this.keys);\n\t        var thisKeys = keypair[0];\n\t        var otherKeys = keypair[1];\n\t\n\t        var childrenPair = (0, _utils.splitAt)(ownerID, cutoff, this.children);\n\t        var thisChildren = childrenPair[0];\n\t        var otherChildren = childrenPair[1];\n\t\n\t        var other = new Leaf({\n\t            order: this.order,\n\t            keys: otherKeys,\n\t            children: otherChildren,\n\t            ownerID: ownerID\n\t        });\n\t\n\t        var thisSplit = void 0;\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            thisSplit = this;\n\t            thisSplit.keys = thisKeys;\n\t            thisSplit.children = thisChildren;\n\t        } else {\n\t            thisSplit = new Leaf({\n\t                order: this.order,\n\t                keys: thisKeys,\n\t                children: thisChildren,\n\t                ownerID: ownerID\n\t            });\n\t        }\n\t\n\t        return [smallestKeyInOther, thisSplit, other];\n\t    },\n\t    smallestKey: function smallestKey() {\n\t        return this.keys[0];\n\t    },\n\t    stealFirstKeyFrom: function stealFirstKeyFrom(ownerID, rightSibling) {\n\t        var stolenKey = rightSibling.keys[0];\n\t        var stolenValue = rightSibling.children[0];\n\t\n\t        // Note: mutative. If we're stealing a key,\n\t        // it means this node was created during\n\t        // the edit and can be mutated.\n\t        this.keys = this.keys.concat(stolenKey);\n\t        this.children = this.children.concat(stolenValue);\n\t\n\t        var siblingWithoutFirstKey = rightSibling.tail(ownerID);\n\t        return [this, siblingWithoutFirstKey];\n\t    },\n\t    giveLastKeyTo: function giveLastKeyTo(ownerID, rightSibling) {\n\t        var keyToGive = this.keys[this.keys.length - 1];\n\t        var valueToGive = this.children[this.children.length - 1];\n\t\n\t        // Note: mutative. If we're giving a key,\n\t        // it means the sibling node was created during\n\t        // the edit and can be mutated.\n\t        rightSibling.keys = (0, _utils.unshift)(ownerID, keyToGive, rightSibling.keys);\n\t        rightSibling.children = (0, _utils.unshift)(ownerID, valueToGive, rightSibling.children);\n\t\n\t        var thisWithoutLastKey = this.init(ownerID);\n\t        return [thisWithoutLastKey, rightSibling];\n\t    }\n\t});\n\t\n\tfunction InternalNode(opts) {\n\t    Node.call(this, opts);\n\t}\n\t\n\tvar REPLACE = 'REPLACE';\n\tvar STEAL_KEY_FROM_LEFT = 'STEAL_KEY_FROM_LEFT';\n\tvar STEAL_KEY_FROM_RIGHT = 'STEAL_KEY_FROM_RIGHT';\n\tvar MERGE = 'MERGE';\n\t\n\tvar DELETION_STRATEGIES = exports.DELETION_STRATEGIES = {\n\t    STEAL_KEY_FROM_LEFT: STEAL_KEY_FROM_LEFT,\n\t    STEAL_KEY_FROM_RIGHT: STEAL_KEY_FROM_RIGHT,\n\t    MERGE: MERGE\n\t};\n\t\n\tInternalNode.prototype = Object.create(Node.prototype);\n\tInternalNode.prototype.constructor = InternalNode;\n\t\n\t(0, _utils.extend)(InternalNode.prototype, {\n\t    maxChildren: _constants.INTERNAL_MAX_CHILDREN,\n\t\n\t    minChildren: _constants.INTERNAL_MIN_CHILDREN,\n\t\n\t    merge: function merge(otherNode) {\n\t        // We have ak + bk keys, and ac + bc children.\n\t        // In a node, ac - ak === 1 (one less key than children).\n\t        // Because (ac + bc) - (ak + bk) === 2, we need to add a key.\n\t        // The key is the smallest key on the right node subtree.\n\t        var toConcat = (0, _utils.unshift)(null, otherNode.smallestKey(), otherNode.keys);\n\t        var newNode = new InternalNode({\n\t            order: this.order,\n\t            keys: this.keys.concat(toConcat),\n\t            children: this.children.concat(otherNode.children)\n\t        });\n\t        return newNode;\n\t    },\n\t    chooseComplexDeletionStrategy: function chooseComplexDeletionStrategy(childIdx, newChild) {\n\t        // When we need to merge, steal or give keys to\n\t        // siblings -- this method returns the operation parameters,\n\t        // which are: the left node, the right node, the index of\n\t        // the left node in this nodes `children` array, and the\n\t        // strategy to use (merge, steal from right, steal from left).\n\t\n\t        if (newChild.satisfiesMinChildren()) {\n\t            return {\n\t                strategy: REPLACE\n\t            };\n\t        }\n\t\n\t        var hasRightSibling = childIdx + 1 < this.children.length;\n\t        var hasLeftSibling = childIdx - 1 >= 0;\n\t\n\t        var isLeaf = newChild.constructor === Leaf;\n\t\n\t        var nullSibling = { size: 0 };\n\t\n\t        var rightSibling = hasRightSibling ? this.children[childIdx + 1] : nullSibling;\n\t\n\t        var leftSibling = hasLeftSibling ? this.children[childIdx - 1] : nullSibling;\n\t\n\t        var minChildren = isLeaf ? _constants.LEAF_MIN_CHILDREN : _constants.INTERNAL_MIN_CHILDREN;\n\t\n\t        var strategy = void 0;\n\t        if (rightSibling.size >= leftSibling.size) {\n\t            if (rightSibling.size <= minChildren) {\n\t                strategy = MERGE;\n\t            } else {\n\t                strategy = STEAL_KEY_FROM_RIGHT;\n\t            }\n\t\n\t            return {\n\t                leftNode: newChild,\n\t                rightNode: rightSibling,\n\t                leftNodeIdx: childIdx,\n\t                strategy: strategy\n\t            };\n\t        } else {\n\t            if (leftSibling.size <= minChildren) {\n\t                strategy = MERGE;\n\t            } else {\n\t                strategy = STEAL_KEY_FROM_LEFT;\n\t            }\n\t            return {\n\t                leftNode: leftSibling,\n\t                rightNode: newChild,\n\t                leftNodeIdx: childIdx - 1,\n\t                strategy: strategy\n\t            };\n\t        }\n\t    },\n\t    delete: function _delete(cmp, ownerID, didChange, key) {\n\t        var childIdx = this.childIdxForKey(cmp, key);\n\t        var origChild = this.children[childIdx];\n\t        var child = origChild.delete(cmp, ownerID, didChange, key);\n\t\n\t        if (!(0, _utils.isSet)(didChange)) return this;\n\t\n\t        var strategyInfo = this.chooseComplexDeletionStrategy(childIdx, child);\n\t        var strategy = strategyInfo.strategy;\n\t\n\t        if (strategy === REPLACE) {\n\t            return this.withReplacedChildren(ownerID, childIdx, [child]);\n\t        }\n\t\n\t        var leftNode = strategyInfo.leftNode;\n\t        var rightNode = strategyInfo.rightNode;\n\t        var leftNodeIdx = strategyInfo.leftNodeIdx;\n\t\n\t\n\t        if (strategy === MERGE) {\n\t            return this.withMergedChildren(ownerID, leftNodeIdx, leftNode, rightNode);\n\t        }\n\t\n\t        var newLeftNode = void 0;\n\t        var newRightNode = void 0;\n\t        if (strategy === STEAL_KEY_FROM_RIGHT) {\n\t            var newNodes = leftNode.stealFirstKeyFrom(ownerID, rightNode);\n\t            newLeftNode = newNodes[0];\n\t            newRightNode = newNodes[1];\n\t        } else if (strategy === STEAL_KEY_FROM_LEFT) {\n\t            var _newNodes = leftNode.giveLastKeyTo(ownerID, rightNode);\n\t            newLeftNode = _newNodes[0];\n\t            newRightNode = _newNodes[1];\n\t        }\n\t\n\t        var withReplacedChildren = this.withReplacedChildren(ownerID, leftNodeIdx, [newLeftNode, newRightNode]);\n\t\n\t        // Key must be updated because of the child key theft.\n\t        var keyIdxToReplace = leftNodeIdx;\n\t        var newKey = newRightNode.smallestKey();\n\t\n\t        withReplacedChildren.keys = (0, _utils.set)(ownerID, keyIdxToReplace, newKey, withReplacedChildren.keys);\n\t        return withReplacedChildren;\n\t    },\n\t    withMergedChildren: function withMergedChildren(ownerID, leftChildIdx, leftNode, rightNode) {\n\t        var mergedChild = leftNode.merge(rightNode);\n\t\n\t        var keyIdxToPop = leftChildIdx;\n\t\n\t        var newKeys = (0, _utils.withoutIdx)(ownerID, keyIdxToPop, this.keys);\n\t\n\t        var areLeftmostNodes = leftChildIdx === 0;\n\t\n\t        if (!areLeftmostNodes) {\n\t            newKeys[leftChildIdx - 1] = mergedChild.smallestKey();\n\t        }\n\t\n\t        var newChildren = (0, _utils.arrayClone)(this.children);\n\t        newChildren.splice(leftChildIdx, 1);\n\t        newChildren[leftChildIdx] = mergedChild;\n\t\n\t        var withReplacedChild = new InternalNode({\n\t            order: this.order,\n\t            keys: newKeys,\n\t            children: newChildren,\n\t            ownerID: ownerID\n\t        });\n\t        return withReplacedChild;\n\t    },\n\t    childIdxForKey: function childIdxForKey(cmp, key) {\n\t        return _binarysearch2.default.lte(this.keys, key, cmp) + 1;\n\t    },\n\t    stealFirstKeyFrom: function stealFirstKeyFrom(ownerID, rightSibling) {\n\t        // Note that we mutate `this`.\n\t        // Whenever we're stealing a first key,\n\t        // it means this node was created during\n\t        // the current update and can be mutated.\n\t        var stolenValue = rightSibling.children[0];\n\t\n\t        this.keys = this.keys.concat(rightSibling.smallestKey());\n\t        this.children = this.children.concat(stolenValue);\n\t\n\t        return [this, rightSibling.tail(ownerID)];\n\t    },\n\t    giveLastKeyTo: function giveLastKeyTo(ownerID, rightSibling) {\n\t        // Steal last key-value pair from left node\n\t        var stolenValue = (0, _utils.last)(this.children);\n\t        rightSibling.keys = (0, _utils.unshift)(ownerID, rightSibling.smallestKey(), rightSibling.keys);\n\t        rightSibling.children = (0, _utils.unshift)(ownerID, stolenValue, rightSibling.children);\n\t\n\t        return [this.init(ownerID), rightSibling];\n\t    },\n\t    withReplacedChildren: function withReplacedChildren(ownerID, idx, newChildren) {\n\t        var replaced = (0, _utils.canMutate)(this.children, ownerID) ? this.children : (0, _utils.arrayClone)(this.children);\n\t\n\t        for (var i = 0; i < newChildren.length; i++) {\n\t            replaced[idx + i] = newChildren[i];\n\t        }\n\t\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            this.children = replaced;\n\t            return this;\n\t        }\n\t\n\t        return new InternalNode({\n\t            order: this.order,\n\t            keys: this.keys,\n\t            children: replaced,\n\t            ownerID: ownerID\n\t        });\n\t    },\n\t    smallestKey: function smallestKey() {\n\t        var curr = this;\n\t        while (curr.constructor !== Leaf) {\n\t            curr = curr.children[0];\n\t        }\n\t        return curr.keys[0];\n\t    },\n\t    split: function split(ownerID) {\n\t        var medianIdx = (0, _utils.median)(this.keys.length) - 1;\n\t\n\t        var splitArr = (0, _utils.takeIdxAndSplit)(ownerID, medianIdx, this.keys);\n\t        var thisKeys = splitArr[0];\n\t        var medianKey = splitArr[1];\n\t        var otherKeys = splitArr[2];\n\t\n\t        var childrenPair = (0, _utils.splitAt)(ownerID, medianIdx + 1, this.children);\n\t        var thisChildren = childrenPair[0];\n\t        var otherChildren = childrenPair[1];\n\t\n\t        var thisNode = void 0;\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            thisNode = this;\n\t            thisNode.keys = thisKeys;\n\t            thisNode.children = thisChildren;\n\t        } else {\n\t            thisNode = new InternalNode({\n\t                order: this.order,\n\t                keys: thisKeys,\n\t                children: thisChildren,\n\t                ownerID: ownerID\n\t            });\n\t        }\n\t\n\t        var otherNode = new InternalNode({\n\t            order: this.order,\n\t            keys: otherKeys,\n\t            children: otherChildren,\n\t            ownerID: ownerID\n\t        });\n\t\n\t        return [medianKey, thisNode, otherNode];\n\t    },\n\t    withSplitChild: function withSplitChild(cmp, ownerID, newKey, splitChild, newChild) {\n\t        var insertNewKeyAt = internalInsertKeyAt(cmp, newKey, this.keys);\n\t        var newKeys = (0, _utils.insert)(ownerID, insertNewKeyAt, newKey, this.keys);\n\t\n\t        var newChildren = (0, _utils.insert)(ownerID, insertNewKeyAt + 1, newChild, this.children);\n\t        // Replace the original child with the split one.\n\t        newChildren[insertNewKeyAt] = splitChild;\n\t\n\t        if ((0, _utils.canMutate)(this, ownerID)) {\n\t            this.keys = newKeys;\n\t            this.children = newChildren;\n\t            return this;\n\t        }\n\t\n\t        return new InternalNode({\n\t            order: this.order,\n\t            keys: newKeys,\n\t            children: newChildren,\n\t            ownerID: ownerID\n\t        });\n\t    },\n\t    insert: function insert(cmp, ownerID, didChange, key, value) {\n\t        var childIdx = this.childIdxForKey(cmp, key);\n\t        var child = this.children[childIdx];\n\t\n\t        var newChild = child.insert(cmp, ownerID, didChange, key, value);\n\t\n\t        if (!(0, _utils.isSet)(didChange)) return this;\n\t\n\t        // Got new child.\n\t\n\t        // Child was split on insertion.\n\t        if (newChild.length === 3) {\n\t            var splitArr = newChild;\n\t            var medianKey = splitArr[0];\n\t            var splitChild = splitArr[1];\n\t            var _newChild = splitArr[2];\n\t\n\t            var withSplitChild = this.withSplitChild(cmp, ownerID, medianKey, splitChild, _newChild);\n\t            return withSplitChild.shouldSplit() ? withSplitChild.split(ownerID) : withSplitChild;\n\t        }\n\t\n\t        return this.withReplacedChildren(ownerID, childIdx, [newChild]);\n\t    }\n\t});\n\t\n\texports.Node = Node;\n\texports.Leaf = Leaf;\n\texports.InternalNode = InternalNode;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar MIN_ROOT_CHILDREN = exports.MIN_ROOT_CHILDREN = 2;\n\t\n\t// These numbers are optimized for the Path implementation.\n\t// With these values we can store paths in the binary representation\n\t// of an integer - the lowest 30 bits divide to 5 parts of 6 bits each.\n\t// During range searches and iteration, we check if we've reached the\n\t// end path at each element. When the path is represented as an integer,\n\t// we can do a fast integer comparison.\n\t//\n\t// 6 bits gives us a range of 2^6 = 64 values for each part.\n\t// The maximum tree size with these limitations should be more than enough,\n\t// 64^5 - 1 = 1,073,741,823, that's about 1 billion elements.\n\tvar ORDER = exports.ORDER = 64;\n\tvar SHIFT_LEN = exports.SHIFT_LEN = 6;\n\t\n\tvar LEAF_MIN_CHILDREN = exports.LEAF_MIN_CHILDREN = Math.ceil(ORDER / 2) - 1;\n\tvar LEAF_MAX_CHILDREN = exports.LEAF_MAX_CHILDREN = ORDER - 1;\n\tvar INTERNAL_MIN_CHILDREN = exports.INTERNAL_MIN_CHILDREN = Math.ceil(ORDER / 2);\n\tvar INTERNAL_MAX_CHILDREN = exports.INTERNAL_MAX_CHILDREN = ORDER;\n\t\n\tvar ITERATOR_PROPNAME = exports.ITERATOR_PROPNAME = typeof Symbol === 'function' ? Symbol.iterator : '@@iterator';\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.boundedChunk = exports.takeIdxAndSplit = exports.median = undefined;\n\texports.makeOwnerID = makeOwnerID;\n\texports.tagOwnerID = tagOwnerID;\n\texports.canMutate = canMutate;\n\texports.slice = slice;\n\texports.arrayClone = arrayClone;\n\texports.withoutIdx = withoutIdx;\n\texports.insert = insert;\n\texports.set = set;\n\texports.fastMap = fastMap;\n\texports.splitAt = splitAt;\n\texports.unshift = unshift;\n\texports.last = last;\n\texports.init = init;\n\texports.tail = tail;\n\texports.getEmptyIterator = getEmptyIterator;\n\texports.extend = extend;\n\texports.makeRef = makeRef;\n\texports.setRef = setRef;\n\texports.isSet = isSet;\n\texports.normalizeRangeSpec = normalizeRangeSpec;\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tvar median = exports.median = function median(len) {\n\t    return Math.ceil(len / 2);\n\t};\n\t\n\tfunction makeOwnerID() {\n\t    return {};\n\t}\n\t\n\tfunction tagOwnerID(obj, ownerID) {\n\t    obj.ownerID = ownerID;\n\t    return obj;\n\t}\n\t\n\tfunction canMutate(obj, ownerID) {\n\t    return ownerID && ownerID === obj.ownerID;\n\t}\n\t\n\tfunction allocateArray(ownerID, len) {\n\t    return tagOwnerID(len ? new Array(len) : [], ownerID);\n\t}\n\t\n\tfunction slice(ownerID, start, end, arr) {\n\t    var newLen = end - start;\n\t    if (canMutate(arr, ownerID)) {\n\t        var removeNFromStart = start;\n\t        var removeNFromEnd = arr.length - end;\n\t        while (removeNFromStart--) {\n\t            arr.shift();\n\t        }\n\t        while (removeNFromEnd--) {\n\t            arr.pop();\n\t        }\n\t\n\t        return arr;\n\t    }\n\t\n\t    var newArr = allocateArray(ownerID, newLen);\n\t    for (var i = start; i < end; i++) {\n\t        newArr[i - start] = arr[i];\n\t    }\n\t    return newArr;\n\t}\n\t\n\tfunction arrayClone(arr) {\n\t    var len = arr.length;\n\t    var copy = new Array(len);\n\t\n\t    for (var i = 0; i < len; i++) {\n\t        copy[i] = arr[i];\n\t    }\n\t    return copy;\n\t}\n\t\n\tfunction withoutIdx(ownerID, idx, arr) {\n\t    var copied = canMutate(arr, ownerID) ? arr : tagOwnerID(arrayClone(arr), ownerID);\n\t\n\t    copied.splice(idx, 1);\n\t    return copied;\n\t}\n\t\n\tfunction insert(ownerID, idx, val, arr) {\n\t    if (canMutate(arr, ownerID)) {\n\t        arr.splice(idx, 0, val);\n\t        return arr;\n\t    }\n\t\n\t    var newArrLen = arr.length + 1;\n\t    var newArr = new Array(newArrLen);\n\t\n\t    var i = 0;\n\t    for (; i < idx; i++) {\n\t        newArr[i] = arr[i];\n\t    }\n\t\n\t    newArr[i++] = val;\n\t\n\t    for (; i < newArrLen; i++) {\n\t        newArr[i] = arr[i - 1];\n\t    }\n\t\n\t    return newArr;\n\t}\n\t\n\tfunction set(ownerID, idx, val, arr) {\n\t    var copied = canMutate(arr, ownerID) ? arr : tagOwnerID(arrayClone(arr), ownerID);\n\t\n\t    copied[idx] = val;\n\t    return copied;\n\t}\n\t\n\tfunction fastMap(fn, arr) {\n\t    var copied = arrayClone(arr);\n\t    var len = arr.length;\n\t    for (var i = 0; i < len; i++) {\n\t        copied[i] = fn(arr[i], i);\n\t    }\n\t    return copied;\n\t}\n\t\n\tfunction splitAt(ownerID, idx, arr) {\n\t    var arrLen = arr.length;\n\t    var firstArrLen = idx;\n\t    var secondArrLen = arrLen - idx;\n\t    var secondArr = allocateArray(ownerID, secondArrLen);\n\t\n\t    var firstArr = allocateArray(ownerID, firstArrLen);\n\t\n\t    for (var i = 0; i < idx; i++) {\n\t        firstArr[i] = arr[i];\n\t    }\n\t\n\t    for (var _i = idx; _i < arrLen; _i++) {\n\t        secondArr[_i - idx] = arr[_i];\n\t    }\n\t\n\t    return [firstArr, secondArr];\n\t}\n\t\n\tfunction unshift(ownerID, value, arr) {\n\t    return insert(ownerID, 0, value, arr);\n\t}\n\t\n\tvar takeIdxAndSplit = exports.takeIdxAndSplit = function takeIdxAndSplit(ownerID, idx, arr) {\n\t    var cutoff = idx;\n\t    var a1len = cutoff;\n\t    var arr1 = slice(ownerID, 0, a1len, arr);\n\t    var arr2 = slice(ownerID, cutoff + 1, arr.length, arr);\n\t    return [arr1, arr[cutoff], arr2];\n\t};\n\t\n\tfunction last(arr) {\n\t    return arr[arr.length - 1];\n\t}\n\t\n\tfunction init(ownerID, arr) {\n\t    if (canMutate(arr, ownerID)) {\n\t        if (arr.length === 0) return arr;\n\t        arr.pop();\n\t        return arr;\n\t    }\n\t\n\t    if (arr.length <= 1) return allocateArray(ownerID);\n\t    return slice(ownerID, 0, arr.length - 1, arr);\n\t}\n\t\n\tfunction tail(ownerID, arr) {\n\t    if (canMutate(arr, ownerID)) {\n\t        arr.shift();\n\t        return arr;\n\t    }\n\t\n\t    if (arr.length <= 1) return tagOwnerID([], ownerID);\n\t    return slice(ownerID, 1, arr.length, arr);\n\t}\n\t\n\tfunction getEmptyIterator() {\n\t    var iterator = {\n\t        next: function next() {\n\t            return { done: true };\n\t        }\n\t    };\n\t\n\t    iterator[_constants.ITERATOR_PROPNAME] = function () {\n\t        return iterator;\n\t    };\n\t\n\t    return iterator;\n\t}\n\t\n\tvar boundedChunk = exports.boundedChunk = function boundedChunk(min, max, arr) {\n\t    var arrLen = arr.length;\n\t    if (!arr.length) return [];\n\t    if (arr.length <= max) {\n\t        return [arr];\n\t    }\n\t\n\t    var avg = Math.ceil((min + max) / 2);\n\t    var parts = arrLen / avg;\n\t    var chunkCount = Math.ceil(parts);\n\t    var splitsize = 1 / chunkCount * arrLen;\n\t    var chunks = new Array(chunkCount);\n\t    for (var i = 0; i < chunkCount; i++) {\n\t        chunks[i] = arr.slice(Math.ceil(i * splitsize), Math.ceil((i + 1) * splitsize));\n\t    }\n\t    return chunks;\n\t};\n\t\n\tfunction extend(target) {\n\t    var argsLen = arguments.length;\n\t    var source = void 0;\n\t    var keys = void 0;\n\t    var key = void 0;\n\t    var i = void 0;\n\t    var j = void 0;\n\t\n\t    for (j = 1; j < argsLen; j++) {\n\t        source = arguments[j];\n\t        keys = Object.keys(source);\n\t        for (i = 0; i < keys.length; i++) {\n\t            key = keys[i];\n\t            target[key] = source[key];\n\t        }\n\t    }\n\t    return target;\n\t}\n\t\n\tfunction makeRef(value) {\n\t    return { value: value };\n\t}\n\t\n\tfunction setRef(ref) {\n\t    ref.value = true;\n\t}\n\t\n\tfunction isSet(ref) {\n\t    return !!ref.value;\n\t}\n\t\n\tfunction normalizeRangeSpec(spec) {\n\t    return {\n\t        from: spec.from,\n\t        to: spec.to,\n\t        fromInclusive: spec.hasOwnProperty('fromInclusive') ? spec.fromInclusive : true,\n\t        toInclusive: spec.hasOwnProperty('toInclusive') ? spec.toInclusive : true\n\t    };\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Path = exports.safePathSet = exports.clearBitRange = exports.pathSet = exports.pathGet = exports.bitSlice = exports.LEVELS = undefined;\n\t\n\tvar _constants = __webpack_require__(3);\n\t\n\tvar _utils = __webpack_require__(4);\n\t\n\tvar MIN_PATH = 0;\n\tvar NUMBER_OF_UNSIGNED_BITS = 31;\n\t\n\tvar LEVELS = exports.LEVELS = Math.floor(NUMBER_OF_UNSIGNED_BITS / _constants.SHIFT_LEN);\n\t\n\t/**\n\t * Slices a range of bits from the binary\n\t * representation of a number.\n\t *\n\t * Example:\n\t *     num: decimal 376 = binary 101111000\n\t *     fromBit: 3\n\t *     toBit: 9\n\t *     Returns decimal 47 = binary 101111\n\t *\n\t * @param  {Number} fromBit - bit to start slicing from, inclusive\n\t * @param  {Number} toBit - bit to stop slicing at, exclusive\n\t * @param  {Number} num - number to slice\n\t * @return {Number} sliced number\n\t */\n\tvar bitSlice = exports.bitSlice = function bitSlice(fromBit, toBit, num) {\n\t    // toBit exclusive. Mask is from bits 0..toBit - 1.\n\t    var mask = Math.pow(2, toBit) - 1;\n\t\n\t    return (num & mask) >>> fromBit;\n\t};\n\t\n\t/**\n\t * Gets the path value for a given level.\n\t *\n\t * Example:\n\t *     shiftLen: 6\n\t *     level: 1\n\t *     path:  decimal 16518336 = binary 111111 000000 110011 000000\n\t *     Returns: decimal 51 = 110011\n\t *\n\t * @param  {Number} shiftLen - the binary representation length of a single level\n\t * @param  {Number} level - the level to get a value from, starting at 0\n\t * @param  {Number} path - input path\n\t * @return {Number} value for `path` at level `level`\n\t */\n\tvar pathGet = exports.pathGet = function pathGet(shiftLen, level, path) {\n\t    return bitSlice(shiftLen * level, shiftLen * (level + 1), path);\n\t};\n\t\n\t/**\n\t * Returns a new updated path where the value for a given level is\n\t * set to `newValue`. The current value of path at the given level must be 0.\n\t *\n\t * @param  {Number} shiftLen - the binary representation length of a single level\n\t * @param  {Number} level - the level to set the value to, starting at 0\n\t * @param  {Number} path\n\t * @param  {Number} newValue\n\t * @return {Number} an updated path\n\t */\n\tvar pathSet = exports.pathSet = function pathSet(shiftLen, level, path, newValue) {\n\t    return path | newValue << shiftLen * level;\n\t};\n\t\n\tvar clearBitRange = exports.clearBitRange = function clearBitRange(fromBit, toBit, num) {\n\t    var rangeLen = toBit - fromBit;\n\t    var mask = Math.pow(2, rangeLen) - 1;\n\t    return num & ~(mask << fromBit);\n\t};\n\t\n\t// Safe version of `pathSet` where the current value is cleared before\n\t// assigning a new value.\n\tvar safePathSet = exports.safePathSet = function safePathSet(shiftLen, level, path, newValue) {\n\t    var cleared = clearBitRange(shiftLen * level, shiftLen * (level + 1), path);\n\t    return pathSet(shiftLen, level, cleared, newValue);\n\t};\n\t\n\tfunction Path(shiftLen, levels, path) {\n\t    this.shiftLen = shiftLen || _constants.SHIFT_LEN;\n\t    this.length = levels || LEVELS;\n\t    this._path = path || 0;\n\t}\n\t\n\tPath.EMPTY_PATH = new Path(_constants.SHIFT_LEN, LEVELS, MIN_PATH);\n\tPath.from = function from(arr) {\n\t    var levels = arr.length;\n\t\n\t    var path = 0;\n\t    for (var i = 0; i < levels; i++) {\n\t        path = pathSet(_constants.SHIFT_LEN, i, path, arr[i]);\n\t    }\n\t\n\t    return new Path(_constants.SHIFT_LEN, levels, path);\n\t};\n\t\n\t(0, _utils.extend)(Path.prototype, {\n\t    get: function get(level) {\n\t        return pathGet(this.shiftLen, level, this._path);\n\t    },\n\t    equals: function equals(otherPath) {\n\t        return this._path === otherPath._path;\n\t    },\n\t    clearAfter: function clearAfter(level) {\n\t        var currLevel = level + 1;\n\t        var newPath = this;\n\t        while (currLevel < this.length) {\n\t            newPath = newPath.set(currLevel, 0);\n\t            currLevel++;\n\t        }\n\t        return newPath;\n\t    },\n\t    toArray: function toArray() {\n\t        var arr = new Array(this.length);\n\t        for (var i = 0; i < this.length; i++) {\n\t            arr[i] = this.get(i);\n\t        }\n\t        return arr;\n\t    },\n\t    compareTo: function compareTo(otherPath) {\n\t        var a = this._path;\n\t        var b = otherPath._path;\n\t        return a === b ? 0 : a < b ? -1 : 1; // eslint-disable-line no-nested-ternary\n\t    },\n\t    increment: function increment(level) {\n\t        var newPath = this.set(level, this.get(level) + 1);\n\t        return newPath.clearAfter(level);\n\t    },\n\t    decrement: function decrement(level) {\n\t        return this.set(level, this.get(level) - 1);\n\t    },\n\t    set: function set(level, value) {\n\t        var newPath = safePathSet(this.shiftLen, level, this._path, value);\n\t        return new Path(this.shiftLen, this.length, newPath);\n\t    }\n\t});\n\t\n\texports.Path = Path;\n\texports.default = Path;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ibtree.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7018d92107faff2ed869\n **/","import binarySearch from './binarysearch';\nimport { Leaf, InternalNode } from './nodes';\nimport Path from './path';\nimport {\n    fastMap,\n    getEmptyIterator,\n    tail,\n    boundedChunk,\n    extend,\n    makeOwnerID,\n    tagOwnerID,\n    makeRef,\n    isSet,\n    normalizeRangeSpec,\n} from './utils';\nimport {\n    ORDER,\n    MIN_ROOT_CHILDREN,\n    SHIFT_LEN,\n    LEAF_MIN_CHILDREN,\n    LEAF_MAX_CHILDREN,\n    INTERNAL_MIN_CHILDREN,\n    INTERNAL_MAX_CHILDREN,\n    ITERATOR_PROPNAME,\n} from './constants';\n\nconst binSearch = binarySearch.eq;\n\nconst NOT_FOUND = {};\n\n\nexport const defaultComparator = (a, b) => // eslint-disable-line no-confusing-arrow\n    a === b // eslint-disable-line no-nested-ternary\n        ? 0\n        : a < b\n            ? -1\n            : 1;\n\n\n// Iterator extraction funcs\n\nconst extractValue = (leaf, idx) => leaf.children[idx];\nconst extractKey = (leaf, idx) => leaf.keys[idx];\nconst extractEntry = (leaf, idx) => [extractKey(leaf, idx), extractValue(leaf, idx)];\n\n\nexport function BPlusTree(_opts) {\n    const opts = _opts || {};\n    this.order = ORDER;\n\n    // Used to decide whether @@iterator returns\n    // values or entries.\n    this.isSet = opts.isSet === undefined ? false : opts.isSet;\n\n    this.extractor = opts.extractor; // May be undefined on purpose.\n    this.comparator = opts.comparator || defaultComparator;\n\n    this.root = opts.root || new Leaf({ order: this.order });\n    this.size = opts.size || 0;\n    this.height = opts.height || 0;\n    this.ownerID = opts.ownerID;\n}\n\nextend(BPlusTree.prototype, {\n    has(key) {\n        return this.search(this.comparator, key) !== NOT_FOUND;\n    },\n\n    add(value) {\n        return this.set(value, value);\n    },\n\n    get(key) {\n        const val = this.search(this.comparator, key);\n        return val === NOT_FOUND\n            ? undefined\n            : val;\n    },\n\n    clear() {\n        return new this.constructor({\n            comparator: this.comparator,\n            extractor: this.extractor,\n        });\n    },\n\n    set(key, value) {\n        const cmp = this.comparator;\n        const extractedKey = this.extractor\n            ? this.extractor(key)\n            : key;\n\n        const didChange = makeRef(false);\n        const result = this.root.insert(cmp, this.ownerID, didChange, extractedKey, value);\n\n        if (!isSet(didChange)) return this;\n\n        let newRoot;\n        let rootSplit = false;\n        const canMutate = !!this.ownerID;\n\n        // Root was split\n        if (result.length === 3) {\n            rootSplit = true;\n            const splitArr = result;\n            const medianKey = splitArr[0];\n            const splitChild = splitArr[1];\n            const newChild = splitArr[2];\n\n            const newRootKeys = tagOwnerID([medianKey], this.ownerID);\n            const newRootChildren = tagOwnerID([splitChild, newChild], this.ownerID);\n\n            newRoot = new InternalNode({\n                order: this.order,\n                keys: newRootKeys,\n                children: newRootChildren,\n            });\n        } else {\n            newRoot = result;\n        }\n\n        const newHeight = rootSplit ? this.height + 1 : this.height;\n        const newSize = this.size + 1;\n\n        if (canMutate) {\n            this.height = newHeight;\n            this.size = newSize;\n            this.root = newRoot;\n            this._didAlter = true;\n            return this;\n        }\n        return new this.constructor({\n            extractor: this.extractor,\n            comparator: this.comparator,\n            root: newRoot,\n            height: newHeight,\n            size: newSize,\n            ownerID: this.ownerID,\n        });\n    },\n\n    delete(key) {\n        const didChange = makeRef(false);\n        let newRoot = this.root.delete(\n            this.comparator,\n            this.ownerID,\n            didChange,\n            key\n        );\n\n        if (!isSet(didChange)) return this;\n\n        let rootMerged = false;\n        if (newRoot.size < MIN_ROOT_CHILDREN) {\n            const isLeaf = newRoot.constructor === Leaf;\n            if (!isLeaf) {\n                // Since the minimum number of children in\n                // the root is 2, the root must have a single\n                // child.\n                newRoot = newRoot.children[0];\n                rootMerged = true;\n            }\n            // If the root is a leaf, it can be empty.\n        }\n\n        const canMutate = !!this.ownerID;\n\n        let newTree;\n        const newHeight = rootMerged ? this.height - 1 : this.height;\n        const newSize = this.size - 1;\n\n        if (canMutate) {\n            newTree = this;\n            this.root = newRoot;\n            this.height = newHeight;\n            this.size = newSize;\n            this._didAlter = true;\n        } else {\n            newTree = new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: newRoot,\n                height: newHeight,\n                size: newSize,\n                ownerID: this.ownerID,\n            });\n        }\n        return newTree;\n    },\n\n    asMutable() {\n        return this.ownerID\n            ? this\n            : new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: this.root,\n                height: this.height,\n                size: this.size,\n                ownerID: makeOwnerID(),\n            });\n    },\n\n    asImmutable() {\n        return this.ownerID\n            ? new this.constructor({\n                comparator: this.comparator,\n                extractor: this.extractor,\n                root: this.root,\n                height: this.height,\n                size: this.size,\n            })\n            : this;\n    },\n\n    withMutations(fn) {\n        const mutable = this.asMutable();\n        fn(mutable);\n        return mutable._didAlter ? mutable.asImmutable() : this;\n    },\n\n    _baseBetween(extractor, _rangeSpec) {\n        if (this.size === 0) return getEmptyIterator();\n\n        const rangeSpec = normalizeRangeSpec(_rangeSpec);\n\n        const fromKey = this.extractor\n            ? this.extractor(rangeSpec.from)\n            : rangeSpec.from;\n\n        const toKey = this.extractor\n            ? this.extractor(rangeSpec.to)\n            : rangeSpec.to;\n\n        const isReverse = this.comparator(fromKey, toKey) > 0;\n\n        const fromIsRight = isReverse;\n        const toIsRight = !fromIsRight;\n\n        const fromPath = this.findPath(fromKey, fromIsRight, rangeSpec.fromInclusive);\n        const toPath = this.findPath(toKey, toIsRight, rangeSpec.toInclusive);\n\n        if (fromPath === null || toPath === null) {\n            return getEmptyIterator();\n        }\n\n        return this._iteratorFromTo(\n            extractor,\n            fromPath,\n            toPath,\n            isReverse\n        );\n    },\n\n    between(fromKey, toKey) {\n        if (arguments.length === 1) {\n            const rangeSpec = arguments[0];\n            return this._baseBetween(extractEntry, rangeSpec);\n        }\n\n        const spec = {\n            from: fromKey,\n            to: toKey,\n        };\n\n        return this._baseBetween(extractEntry, spec);\n    },\n\n    /**\n     * Returns the internal and leaf nodes\n     * on the path from root to value.\n     *\n     * @param  {Path} path\n     * @return {Array[Node]}\n     */\n    _pathNodes(path) {\n        const nodes = new Array(path.length);\n\n        let curr = this.root;\n        for (let i = 0; i < path.length; i++) {\n            nodes[i] = curr;\n            curr = curr.children[path.get(i)];\n        }\n\n        return nodes;\n    },\n\n    _nextPath(path) {\n        const nodes = this._pathNodes(path);\n        let level = nodes.length - 1;\n\n        // Simple case: leaf index can be incremented.\n        if (path.get(level) < nodes[level].children.length - 1) {\n            return path.increment(level);\n        }\n\n        level--;\n        // Go through the node path starting from the lowest internal node and\n        // find the first node we can increment a key for.\n        while (level >= 0 && path.get(level) === nodes[level].children.length - 1) level--;\n        // All nodes were at their maximum key\n        if (level < 0) return null;\n        return path.increment(level);\n    },\n\n    _prevPath(path) {\n        // Leftmost path - can't decrement.\n        if (path.equals(Path.EMPTY_PATH)) return null;\n\n        const nodes = this._pathNodes(path);\n\n        let level = path.length - 1;\n        while (path.get(level) === 0) level--;\n\n        let newPath = path.set(level, path.get(level) - 1);\n\n        // Set all the lower keys to their\n        // maximum value.\n        let curr = nodes[level].children[newPath.get(level)];\n        level++;\n        for (; level < path.length; level++) {\n            const childLen = curr.children.length;\n            newPath = newPath.set(level, childLen - 1);\n            curr = curr.children[childLen - 1];\n        }\n        return newPath;\n    },\n\n    _iterateAllWithExtractFn(extractFn) {\n        if (this.size === 0) return getEmptyIterator();\n\n        return this._iteratorFromTo(\n            extractFn,\n            this._getLeftmostPath(),\n            this._getRightmostPath()\n        );\n    },\n\n    _getLeafFromPath(path) {\n        const level = this.height;\n\n        let currLevel = 0;\n        let currNode = this.root;\n\n        while (currLevel !== level) {\n            currNode = currNode.children[path.get(currLevel++)];\n        }\n        return currNode;\n    },\n\n    _getRightmostPath() {\n        if (this.size === 0) return null;\n\n        const keypath = [];\n        let curr = this.root;\n        let currLevel = 0;\n        const leafLevel = this.height;\n\n        while (currLevel !== leafLevel + 1) {\n            const idx = curr.children.length - 1;\n            keypath.push(idx);\n            curr = curr.children[idx];\n            currLevel++;\n        }\n        return Path.from(keypath);\n    },\n\n    _getLeftmostPath() {\n        if (this.size === 0) {\n            return null;\n        }\n\n        return new Path(SHIFT_LEN, this.height + 1);\n    },\n\n    _iteratorFromTo(extractFn, fromPath, toPath, isReverse) {\n        const getPathSuccessor = isReverse\n            ? this._prevPath.bind(this)\n            : this._nextPath.bind(this);\n\n        const leafLevel = this.height;\n\n        let currPath = fromPath;\n\n        // Most of the time we're just getting the next\n        // value from a leaf, so it makes sense to cache\n        // the leaf instead of looking up the successor\n        // path each time.\n        let leafCacheRef;\n        let done = false;\n        const iterator = {\n            next: () => {\n                const pathsEq = currPath !== null && currPath.equals(toPath);\n                if (currPath !== null && (!pathsEq || !done)) {\n                    const valIdx = currPath.get(leafLevel);\n                    const leaf = leafCacheRef || this._getLeafFromPath(currPath);\n                    if (!pathsEq) {\n                        if (isReverse && valIdx > 0) {\n                            // Can decrement leaf index\n                            currPath = currPath.decrement(leafLevel);\n                        } else if (!isReverse && valIdx < leaf.children.length - 1) {\n                            // Can increment leaf idx\n                            currPath = currPath.increment(leafLevel);\n                        } else {\n                            currPath = getPathSuccessor(currPath);\n                            leafCacheRef = undefined;\n                        }\n                    } else {\n                        done = true;\n                    }\n\n                    const value = extractFn(leaf, valIdx);\n\n                    return {\n                        value,\n                    };\n                }\n\n                return {\n                    done: true,\n                };\n            },\n        };\n\n        iterator[ITERATOR_PROPNAME] = () => iterator;\n\n        return iterator;\n    },\n\n    findPath(key, fromRight, isInclusive) {\n        if (this.size === 0) return null;\n\n        const cmp = this.comparator;\n\n        let curr = this.root;\n        const numAccessesToReachLeaf = this.height;\n\n        // Path needs one more value (which key to look up in leaf)\n        const keypath = new Array(numAccessesToReachLeaf + 1);\n\n        let i = 0;\n        let prev = curr;\n        for (; i < numAccessesToReachLeaf; i++) {\n            const idx = curr.childIdxForKey(cmp, key);\n            keypath[i] = idx;\n            prev = curr;\n            curr = curr.children[idx];\n        }\n\n        const parent = prev;\n\n        const searchFuncName = (fromRight ? 'lt' : 'gt') + (isInclusive ? 'e' : '');\n        const searchFunc = binarySearch[searchFuncName];\n\n        // curr should be a leaf now.\n        const idx = searchFunc(curr.keys, key, cmp);\n\n        if (idx === curr.keys.length) {\n            if (!fromRight) {\n                // The key we're looking for could be in the right leaf.\n                keypath[i - 1]++;\n\n                const hasRightLeaf = keypath[i - 1] < parent.children.length;\n                if (!hasRightLeaf) return null;\n                curr = parent.children[keypath[i - 1]];\n                if (curr.keys[0] >= key) {\n                    keypath[i] = 0;\n                } else {\n                    // out of bounds.\n                    return null;\n                }\n            } else {\n                keypath[i] = idx - 1;\n            }\n        } else if (idx === -1) {\n            if (fromRight) {\n                // the key we're looking for could be in the left leaf.\n                keypath[i - 1]--;\n\n                const hasLeftLeaf = keypath[i - 1] >= 0;\n                if (!hasLeftLeaf) return null;\n\n                curr = parent.children[keypath[i - 1]];\n                if (curr.keys[curr.keys.length - 1] <= key) {\n                    keypath[i] = curr.keys.length - 1;\n                } else {\n                    // out of bounds.\n                    return null;\n                }\n            } else {\n                keypath[i] = 0;\n            }\n        } else {\n            keypath[i] = idx;\n        }\n\n        return Path.from(keypath);\n    },\n\n    findLeaf(cmp, key) {\n        let curr = this.root;\n        const numAccessesToReachLeaf = this.height;\n        for (let i = 0; i < numAccessesToReachLeaf; i++) {\n            const idx = curr.childIdxForKey(cmp, key);\n            curr = curr.children[idx];\n        }\n\n        return curr;\n    },\n\n    search(cmp, key) {\n        const extractedKey = this.extractor\n            ? this.extractor(key)\n            : key;\n\n        const leaf = this.findLeaf(cmp, extractedKey);\n        const idx = binSearch(leaf.keys, extractedKey, cmp);\n        if (idx === -1) {\n            return NOT_FOUND;\n        }\n\n        return leaf.children[idx];\n    },\n\n    visit(fn) {\n        const queue = [this.root];\n        while (queue.length) {\n            const curr = queue.shift();\n            fn(curr);\n            if (curr.constructor !== Leaf && curr.children) {\n                queue.push(...curr.children);\n            }\n        }\n    },\n});\n\nconst makeIteratorMethod = extractor =>\n    function getRangeIterator() {\n        if (arguments.length === 0) {\n            return this._iterateAllWithExtractFn(extractor);\n        } else if (arguments.length === 1) {\n            const spec = arguments[0];\n            this._baseBetween(\n                extractor,\n                spec\n            );\n        }\n\n        const spec = {\n            from: arguments[0],\n            to: arguments[1],\n        };\n\n        return this._baseBetween(extractor, spec);\n    };\n\n\nBPlusTree.prototype.values = makeIteratorMethod(extractValue);\nBPlusTree.prototype.valueRange = BPlusTree.prototype.values;\nBPlusTree.prototype.entries = makeIteratorMethod(extractEntry);\nBPlusTree.prototype.entryRange = BPlusTree.prototype.entries;\nBPlusTree.prototype.keys = makeIteratorMethod(extractKey);\nBPlusTree.prototype.keyRange = BPlusTree.prototype.keys;\n\n\nfunction fromSortedBase(arr, _opts, isPairs) {\n    const opts = _opts || {};\n\n    const order = ORDER;\n\n    // For leftmost nodes, we don't take a key\n    // to their parent. That means the parent\n    // could have one too few children, if it's\n    // already at minimum. This adjusts for that.\n    const MIN_ADJUSTMENT = 1;\n\n    const minPageLen = LEAF_MIN_CHILDREN + MIN_ADJUSTMENT;\n    const maxPageLen = LEAF_MAX_CHILDREN;\n\n    const minNodeChildren = INTERNAL_MIN_CHILDREN;\n    const maxNodeChildren = INTERNAL_MAX_CHILDREN;\n\n    const pages = boundedChunk(minPageLen, maxPageLen, arr);\n\n    const leafs = fastMap(page => {\n        let leafKeys;\n        if (isPairs) {\n            leafKeys = fastMap(item =>\n                opts.extractor\n                    ? opts.extractor(item[0])\n                    : item[0],\n                page\n            );\n        } else {\n            leafKeys = opts.extractor\n                ? fastMap(opts.extractor, page)\n                : page;\n        }\n\n        const leafValues = isPairs\n            ? fastMap(item => item[1], page)\n            : page;\n\n        return new Leaf({\n            order,\n            keys: leafKeys,\n            children: leafValues,\n        });\n    }, pages);\n\n    let newHeight = 0;\n    let newRoot = null;\n    let leafsProcessed = false;\n    if (leafs.length === 1) {\n        newRoot = leafs[0];\n    } else {\n        let currLevel = leafs;\n\n\n        while (currLevel.length > 1) {\n            const chunked = boundedChunk(\n                minNodeChildren + MIN_ADJUSTMENT,\n                maxNodeChildren,\n                currLevel\n            );\n            let firstInChunk = true;\n            const nodes = fastMap(chunk => { // eslint-disable-line\n                // For leafs, we use the first key as the key\n                // for the whole chunk.\n                // For internal nodes, we move the first\n                // key up a level.\n                const operation = leafsProcessed\n                    ? child => {\n                        const _head = child.keys[0];\n                        child.keys = tail(null, child.keys); // eslint-disable-line\n                        return _head;\n                    }\n                    : child => child.keys[0];\n\n                // For the left-most nodes, we don't\n                // take a key from its children.\n                const operateOn = firstInChunk\n                    ? tail(null, chunk)\n                    : chunk;\n\n                const newKeys = fastMap(operation, operateOn);\n\n                firstInChunk = false;\n                return new InternalNode({\n                    order,\n                    keys: newKeys,\n                    children: chunk,\n                });\n            }, chunked);\n\n            if (nodes.length === 0) break;\n            currLevel = nodes;\n            leafsProcessed = true;\n            newHeight++;\n        }\n\n        newRoot = currLevel[0];\n    }\n\n    const _constructor = this;\n    return new _constructor(extend({}, opts, {\n        root: newRoot,\n        size: arr.length,\n        height: newHeight,\n    }));\n}\n\nfunction fromSortedPairs(arr, opts) {\n    return fromSortedBase.call(this, arr, opts, true);\n}\n\nfunction fromSortedValues(arr, opts) {\n    return fromSortedBase.call(this, arr, opts, false);\n}\n\nBPlusTree.from = fromSortedPairs;\n\nBPlusTree.prototype[ITERATOR_PROPNAME] = function iterator() {\n    return this.isSet\n        ? this.values()\n        : this.entries();\n};\n\nexport const BTMap = BPlusTree;\n\nexport function BTSet(_opts) {\n    const opts = _opts || {};\n    opts.isSet = true;\n    BPlusTree.call(this, opts);\n}\n\nBTSet.from = fromSortedValues;\n\nBTSet.prototype = BPlusTree.prototype;\n\nexport default BTMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","function baseLte(inclusive, array, value, cmp) {\n    const len = array.length;\n    if (len === 0 || !(inclusive ? cmp(array[0], value) <= 0 : cmp(array[0], value) < 0)) {\n        return - 1;\n    }\n\n    let l = 0;\n    let r = len;\n    while (r - l > 1) {\n        // In our case, r + l <= 128 so we don't need\n        // to worry about overflow here\n        const mid = (r + l) >>> 1;\n        const item = array[mid];\n        if (inclusive ? cmp(item, value) <= 0 : cmp(item, value) < 0) {\n            l = mid;\n        } else {\n            r = mid;\n        }\n    }\n\n    return l;\n}\n\nexport const lte = baseLte.bind(null, true);\nexport const lt = baseLte.bind(null, false);\n\nexport function baseGte(inclusive, array, value, cmp) {\n    const len = array.length;\n    if (len === 0 || !(inclusive\n            ? cmp(array[len - 1], value) >= 0\n            : cmp(array[len - 1], value) > 0)) return len;\n    let l = -1;\n    let r = len - 1;\n    while (r - l > 1) {\n        const mid = (r + l) >>> 1;\n        const item = array[mid];\n        if (inclusive ? cmp(item, value) >= 0 : cmp(item, value) > 0) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n\n    return r;\n}\n\nexport const gte = baseGte.bind(null, true);\nexport const gt = baseGte.bind(null, false);\n\nexport function eq(array, value, cmp) {\n    const idx = lte(array, value, cmp);\n    if (idx !== -1 && cmp(array[idx], value) === 0) {\n        return idx;\n    }\n    return - 1;\n}\n\nexport default {\n    lt,\n    gt,\n    lte,\n    gte,\n    eq,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binarysearch.js\n **/","import binarySearch from './binarysearch';\nimport {\n    ORDER,\n    LEAF_MIN_CHILDREN,\n    LEAF_MAX_CHILDREN,\n    INTERNAL_MIN_CHILDREN,\n    INTERNAL_MAX_CHILDREN,\n} from './constants';\nimport {\n    takeIdxAndSplit,\n    insert,\n    set,\n    arrayClone,\n    unshift,\n    splitAt,\n    withoutIdx,\n    last,\n    init,\n    tail,\n    median,\n    extend,\n    setRef,\n    isSet,\n    canMutate,\n} from './utils';\n\nconst binSearch = binarySearch.eq;\n\nconst internalInsertKeyAt = (cmp, key, keys) => binarySearch.gte(keys, key, cmp);\n\nfunction Node(_opts) {\n    const opts = _opts || {};\n    this.keys = opts.keys || [];\n    this.children = opts.children || [];\n    this.order = ORDER;\n    this.ownerID = opts.ownerID;\n}\n\nObject.defineProperty(Node.prototype, 'size', {\n    enumerable: true,\n    get() {\n        return this.children.length;\n    },\n});\n\nextend(Node.prototype, {\n    satisfiesMinChildren() {\n        return this.children.length >= this.minChildren;\n    },\n\n    satisfiesMaxChildren() {\n        return this.children.length <= this.maxChildren;\n    },\n\n    tail(ownerID) {\n        return new this.constructor({\n            order: this.order,\n            keys: tail(ownerID, this.keys),\n            children: tail(ownerID, this.children),\n            ownerID,\n        });\n    },\n\n    init(ownerID) {\n        return new this.constructor({\n            order: this.order,\n            keys: init(ownerID, this.keys),\n            children: init(ownerID, this.children),\n            ownerID,\n        });\n    },\n\n    shouldSplit() {\n        return !this.satisfiesMaxChildren();\n    },\n});\n\nfunction Leaf(opts) {\n    Node.call(this, opts);\n}\n\nLeaf.prototype = Object.create(Node.prototype);\nLeaf.prototype.constructor = Leaf;\n\nextend(Leaf.prototype, {\n    maxChildren: LEAF_MAX_CHILDREN,\n\n    minChildren: LEAF_MIN_CHILDREN,\n\n    delete(cmp, ownerID, didChange, key) {\n        const idx = binSearch(this.keys, key, cmp);\n        // Key was not found. No modifications needed.\n        if (idx === -1) {\n            return this;\n        }\n\n        setRef(didChange);\n\n        let newLeaf;\n        const newKeys = withoutIdx(ownerID, idx, this.keys);\n        const newChildren = withoutIdx(ownerID, idx, this.children);\n\n        if (canMutate(this, ownerID)) {\n            newLeaf = this;\n            newLeaf.keys = newKeys;\n            newLeaf.children = newChildren;\n        } else {\n            newLeaf = new Leaf({\n                order: this.order,\n                keys: withoutIdx(ownerID, idx, this.keys),\n                children: withoutIdx(ownerID, idx, this.children),\n                ownerID,\n            });\n        }\n\n        return newLeaf;\n    },\n\n    /**\n     * Returns a new leaf with entries merged\n     * from `otherLeaf`. The keys in `otherLeaf`\n     * must be higher than in the current leaf,\n     * i.e. `otherLeaf` must reside to the right of\n     * this leaf in the tree.\n     * @param  {Leaf} otherLeaf - other leaf to merge\n     * @return {Leaf} a new Leaf with entries merged.\n     */\n    merge(otherLeaf) {\n        return new Leaf({\n            order: this.order,\n            keys: this.keys.concat(otherLeaf.keys),\n            children: this.children.concat(otherLeaf.children),\n        });\n    },\n\n    idxForKey(cmp, key) {\n        return binarySearch.gte(this.keys, key, cmp);\n    },\n\n    insert(cmp, ownerID, didChange, key, value) {\n        const idx = this.idxForKey(cmp, key);\n        const alreadyHasKey = this.keys[idx] === key;\n\n        let newKeys;\n        let newChildren;\n\n        if (!alreadyHasKey) {\n            newKeys = insert(ownerID, idx, key, this.keys);\n            newChildren = insert(ownerID, idx, value, this.children);\n        } else {\n            const existingValue = this.children[idx];\n            if (existingValue === value) {\n                return this;\n            }\n\n            newKeys = set(ownerID, idx, key, this.keys);\n            newChildren = set(ownerID, idx, value, this.children);\n        }\n\n        setRef(didChange);\n\n        let newLeaf;\n        if (canMutate(this, ownerID)) {\n            newLeaf = this;\n            this.keys = newKeys;\n            this.children = newChildren;\n        } else {\n            newLeaf = new Leaf({\n                order: this.order,\n                keys: newKeys,\n                children: newChildren,\n                ownerID,\n            });\n        }\n\n        return newLeaf.shouldSplit()\n            ? newLeaf.split(ownerID)\n            : newLeaf;\n    },\n\n    split(ownerID) {\n        const cutoff = median(this.keys.length);\n        const smallestKeyInOther = this.keys[cutoff];\n\n        const keypair = splitAt(ownerID, cutoff, this.keys);\n        const thisKeys = keypair[0];\n        const otherKeys = keypair[1];\n\n        const childrenPair = splitAt(ownerID, cutoff, this.children);\n        const thisChildren = childrenPair[0];\n        const otherChildren = childrenPair[1];\n\n        const other = new Leaf({\n            order: this.order,\n            keys: otherKeys,\n            children: otherChildren,\n            ownerID,\n        });\n\n        let thisSplit;\n        if (canMutate(this, ownerID)) {\n            thisSplit = this;\n            thisSplit.keys = thisKeys;\n            thisSplit.children = thisChildren;\n        } else {\n            thisSplit = new Leaf({\n                order: this.order,\n                keys: thisKeys,\n                children: thisChildren,\n                ownerID,\n            });\n        }\n\n        return [smallestKeyInOther, thisSplit, other];\n    },\n\n    smallestKey() {\n        return this.keys[0];\n    },\n\n    stealFirstKeyFrom(ownerID, rightSibling) {\n        const stolenKey = rightSibling.keys[0];\n        const stolenValue = rightSibling.children[0];\n\n        // Note: mutative. If we're stealing a key,\n        // it means this node was created during\n        // the edit and can be mutated.\n        this.keys = this.keys.concat(stolenKey);\n        this.children = this.children.concat(stolenValue);\n\n        const siblingWithoutFirstKey = rightSibling.tail(ownerID);\n        return [this, siblingWithoutFirstKey];\n    },\n\n    giveLastKeyTo(ownerID, rightSibling) {\n        const keyToGive = this.keys[this.keys.length - 1];\n        const valueToGive = this.children[this.children.length - 1];\n\n        // Note: mutative. If we're giving a key,\n        // it means the sibling node was created during\n        // the edit and can be mutated.\n        rightSibling.keys = unshift(ownerID, keyToGive, rightSibling.keys);\n        rightSibling.children = unshift(ownerID, valueToGive, rightSibling.children);\n\n        const thisWithoutLastKey = this.init(ownerID);\n        return [thisWithoutLastKey, rightSibling];\n    },\n});\n\nfunction InternalNode(opts) {\n    Node.call(this, opts);\n}\n\n\nconst REPLACE = 'REPLACE';\nconst STEAL_KEY_FROM_LEFT = 'STEAL_KEY_FROM_LEFT';\nconst STEAL_KEY_FROM_RIGHT = 'STEAL_KEY_FROM_RIGHT';\nconst MERGE = 'MERGE';\n\nexport const DELETION_STRATEGIES = {\n    STEAL_KEY_FROM_LEFT,\n    STEAL_KEY_FROM_RIGHT,\n    MERGE,\n};\n\nInternalNode.prototype = Object.create(Node.prototype);\nInternalNode.prototype.constructor = InternalNode;\n\nextend(InternalNode.prototype, {\n    maxChildren: INTERNAL_MAX_CHILDREN,\n\n    minChildren: INTERNAL_MIN_CHILDREN,\n\n    merge(otherNode) {\n        // We have ak + bk keys, and ac + bc children.\n        // In a node, ac - ak === 1 (one less key than children).\n        // Because (ac + bc) - (ak + bk) === 2, we need to add a key.\n        // The key is the smallest key on the right node subtree.\n        const toConcat = unshift(null, otherNode.smallestKey(), otherNode.keys);\n        const newNode = new InternalNode({\n            order: this.order,\n            keys: this.keys.concat(toConcat),\n            children: this.children.concat(otherNode.children),\n        });\n        return newNode;\n    },\n\n    chooseComplexDeletionStrategy(childIdx, newChild) {\n        // When we need to merge, steal or give keys to\n        // siblings -- this method returns the operation parameters,\n        // which are: the left node, the right node, the index of\n        // the left node in this nodes `children` array, and the\n        // strategy to use (merge, steal from right, steal from left).\n\n        if (newChild.satisfiesMinChildren()) {\n            return {\n                strategy: REPLACE,\n            };\n        }\n\n        const hasRightSibling = childIdx + 1 < this.children.length;\n        const hasLeftSibling = childIdx - 1 >= 0;\n\n        const isLeaf = newChild.constructor === Leaf;\n\n        const nullSibling = { size: 0 };\n\n        const rightSibling = hasRightSibling\n            ? this.children[childIdx + 1]\n            : nullSibling;\n\n        const leftSibling = hasLeftSibling\n            ? this.children[childIdx - 1]\n            : nullSibling;\n\n        const minChildren = isLeaf\n            ? LEAF_MIN_CHILDREN\n            : INTERNAL_MIN_CHILDREN;\n\n        let strategy;\n        if (rightSibling.size >= leftSibling.size) {\n            if (rightSibling.size <= minChildren) {\n                strategy = MERGE;\n            } else {\n                strategy = STEAL_KEY_FROM_RIGHT;\n            }\n\n            return {\n                leftNode: newChild,\n                rightNode: rightSibling,\n                leftNodeIdx: childIdx,\n                strategy,\n            };\n        } else {\n            if (leftSibling.size <= minChildren) {\n                strategy = MERGE;\n            } else {\n                strategy = STEAL_KEY_FROM_LEFT;\n            }\n            return {\n                leftNode: leftSibling,\n                rightNode: newChild,\n                leftNodeIdx: childIdx - 1,\n                strategy,\n            };\n        }\n    },\n\n    delete(cmp, ownerID, didChange, key) {\n        const childIdx = this.childIdxForKey(cmp, key);\n        const origChild = this.children[childIdx];\n        const child = origChild.delete(cmp, ownerID, didChange, key);\n\n        if (!isSet(didChange)) return this;\n\n        const strategyInfo = this.chooseComplexDeletionStrategy(childIdx, child);\n        const strategy = strategyInfo.strategy;\n\n        if (strategy === REPLACE) {\n            return this.withReplacedChildren(ownerID, childIdx, [child]);\n        }\n\n        const {\n            leftNode,\n            rightNode,\n            leftNodeIdx,\n        } = strategyInfo;\n\n        if (strategy === MERGE) {\n            return this.withMergedChildren(ownerID, leftNodeIdx, leftNode, rightNode);\n        }\n\n        let newLeftNode;\n        let newRightNode;\n        if (strategy === STEAL_KEY_FROM_RIGHT) {\n            const newNodes = leftNode.stealFirstKeyFrom(ownerID, rightNode);\n            newLeftNode = newNodes[0];\n            newRightNode = newNodes[1];\n        } else if (strategy === STEAL_KEY_FROM_LEFT) {\n            const newNodes = leftNode.giveLastKeyTo(ownerID, rightNode);\n            newLeftNode = newNodes[0];\n            newRightNode = newNodes[1];\n        }\n\n        const withReplacedChildren = this.withReplacedChildren(\n            ownerID,\n            leftNodeIdx,\n            [newLeftNode, newRightNode]\n        );\n\n        // Key must be updated because of the child key theft.\n        const keyIdxToReplace = leftNodeIdx;\n        const newKey = newRightNode.smallestKey();\n\n        withReplacedChildren.keys = set(\n            ownerID,\n            keyIdxToReplace,\n            newKey,\n            withReplacedChildren.keys\n        );\n        return withReplacedChildren;\n    },\n\n    withMergedChildren(ownerID, leftChildIdx, leftNode, rightNode) {\n        const mergedChild = leftNode.merge(rightNode);\n\n        const keyIdxToPop = leftChildIdx;\n\n        const newKeys = withoutIdx(ownerID, keyIdxToPop, this.keys);\n\n        const areLeftmostNodes = leftChildIdx === 0;\n\n        if (!areLeftmostNodes) {\n            newKeys[leftChildIdx - 1] = mergedChild.smallestKey();\n        }\n\n        const newChildren = arrayClone(this.children);\n        newChildren.splice(leftChildIdx, 1);\n        newChildren[leftChildIdx] = mergedChild;\n\n        const withReplacedChild = new InternalNode({\n            order: this.order,\n            keys: newKeys,\n            children: newChildren,\n            ownerID,\n        });\n        return withReplacedChild;\n    },\n\n    childIdxForKey(cmp, key) {\n        return binarySearch.lte(this.keys, key, cmp) + 1;\n    },\n\n    stealFirstKeyFrom(ownerID, rightSibling) {\n        // Note that we mutate `this`.\n        // Whenever we're stealing a first key,\n        // it means this node was created during\n        // the current update and can be mutated.\n        const stolenValue = rightSibling.children[0];\n\n        this.keys = this.keys.concat(rightSibling.smallestKey());\n        this.children = this.children.concat(stolenValue);\n\n        return [this, rightSibling.tail(ownerID)];\n    },\n\n    giveLastKeyTo(ownerID, rightSibling) {\n        // Steal last key-value pair from left node\n        const stolenValue = last(this.children);\n        rightSibling.keys = unshift(ownerID, rightSibling.smallestKey(), rightSibling.keys);\n        rightSibling.children = unshift(ownerID, stolenValue, rightSibling.children);\n\n        return [this.init(ownerID), rightSibling];\n    },\n\n    withReplacedChildren(ownerID, idx, newChildren) {\n        const replaced = canMutate(this.children, ownerID)\n            ? this.children\n            : arrayClone(this.children);\n\n        for (let i = 0; i < newChildren.length; i++) {\n            replaced[idx + i] = newChildren[i];\n        }\n\n        if (canMutate(this, ownerID)) {\n            this.children = replaced;\n            return this;\n        }\n\n        return new InternalNode({\n            order: this.order,\n            keys: this.keys,\n            children: replaced,\n            ownerID,\n        });\n    },\n\n    smallestKey() {\n        let curr = this;\n        while (curr.constructor !== Leaf) {\n            curr = curr.children[0];\n        }\n        return curr.keys[0];\n    },\n\n    split(ownerID) {\n        const medianIdx = median(this.keys.length) - 1;\n\n        const splitArr = takeIdxAndSplit(ownerID, medianIdx, this.keys);\n        const thisKeys = splitArr[0];\n        const medianKey = splitArr[1];\n        const otherKeys = splitArr[2];\n\n        const childrenPair = splitAt(ownerID, medianIdx + 1, this.children);\n        const thisChildren = childrenPair[0];\n        const otherChildren = childrenPair[1];\n\n        let thisNode;\n        if (canMutate(this, ownerID)) {\n            thisNode = this;\n            thisNode.keys = thisKeys;\n            thisNode.children = thisChildren;\n        } else {\n            thisNode = new InternalNode({\n                order: this.order,\n                keys: thisKeys,\n                children: thisChildren,\n                ownerID,\n            });\n        }\n\n        const otherNode = new InternalNode({\n            order: this.order,\n            keys: otherKeys,\n            children: otherChildren,\n            ownerID,\n        });\n\n        return [medianKey, thisNode, otherNode];\n    },\n\n    withSplitChild(cmp, ownerID, newKey, splitChild, newChild) {\n        const insertNewKeyAt = internalInsertKeyAt(cmp, newKey, this.keys);\n        const newKeys = insert(ownerID, insertNewKeyAt, newKey, this.keys);\n\n        const newChildren = insert(ownerID, insertNewKeyAt + 1, newChild, this.children);\n        // Replace the original child with the split one.\n        newChildren[insertNewKeyAt] = splitChild;\n\n        if (canMutate(this, ownerID)) {\n            this.keys = newKeys;\n            this.children = newChildren;\n            return this;\n        }\n\n        return new InternalNode({\n            order: this.order,\n            keys: newKeys,\n            children: newChildren,\n            ownerID,\n        });\n    },\n\n    insert(cmp, ownerID, didChange, key, value) {\n        const childIdx = this.childIdxForKey(cmp, key);\n        const child = this.children[childIdx];\n\n        const newChild = child.insert(cmp, ownerID, didChange, key, value);\n\n        if (!isSet(didChange)) return this;\n\n        // Got new child.\n\n        // Child was split on insertion.\n        if (newChild.length === 3) {\n            const splitArr = newChild;\n            const medianKey = splitArr[0];\n            const splitChild = splitArr[1];\n            const _newChild = splitArr[2];\n\n            const withSplitChild = this.withSplitChild(\n                cmp, ownerID, medianKey, splitChild, _newChild);\n            return withSplitChild.shouldSplit()\n                ? withSplitChild.split(ownerID)\n                : withSplitChild;\n        }\n\n        return this.withReplacedChildren(ownerID, childIdx, [newChild]);\n    },\n});\n\nexport {\n    Node,\n    Leaf,\n    InternalNode,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/nodes.js\n **/","export const MIN_ROOT_CHILDREN = 2;\n\n// These numbers are optimized for the Path implementation.\n// With these values we can store paths in the binary representation\n// of an integer - the lowest 30 bits divide to 5 parts of 6 bits each.\n// During range searches and iteration, we check if we've reached the\n// end path at each element. When the path is represented as an integer,\n// we can do a fast integer comparison.\n//\n// 6 bits gives us a range of 2^6 = 64 values for each part.\n// The maximum tree size with these limitations should be more than enough,\n// 64^5 - 1 = 1,073,741,823, that's about 1 billion elements.\nexport const ORDER = 64;\nexport const SHIFT_LEN = 6;\n\nexport const LEAF_MIN_CHILDREN = Math.ceil(ORDER / 2) - 1;\nexport const LEAF_MAX_CHILDREN = ORDER - 1;\nexport const INTERNAL_MIN_CHILDREN = Math.ceil(ORDER / 2);\nexport const INTERNAL_MAX_CHILDREN = ORDER;\n\nexport const ITERATOR_PROPNAME = typeof Symbol === 'function'\n    ? Symbol.iterator\n    : '@@iterator';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants.js\n **/","import {\n    ITERATOR_PROPNAME,\n} from './constants';\n\nexport const median = len => Math.ceil(len / 2);\n\nexport function makeOwnerID() {\n    return {};\n}\n\nexport function tagOwnerID(obj, ownerID) {\n    obj.ownerID = ownerID;\n    return obj;\n}\n\nexport function canMutate(obj, ownerID) {\n    return ownerID && ownerID === obj.ownerID;\n}\n\nfunction allocateArray(ownerID, len) {\n    return tagOwnerID(len ? new Array(len) : [], ownerID);\n}\n\nexport function slice(ownerID, start, end, arr) {\n    const newLen = end - start;\n    if (canMutate(arr, ownerID)) {\n        let removeNFromStart = start;\n        let removeNFromEnd = arr.length - end;\n        while (removeNFromStart--) {\n            arr.shift();\n        }\n        while (removeNFromEnd--) {\n            arr.pop();\n        }\n\n        return arr;\n    }\n\n    const newArr = allocateArray(ownerID, newLen);\n    for (let i = start; i < end; i++) {\n        newArr[i - start] = arr[i];\n    }\n    return newArr;\n}\n\nexport function arrayClone(arr) {\n    const len = arr.length;\n    const copy = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\n\nexport function withoutIdx(ownerID, idx, arr) {\n    const copied = canMutate(arr, ownerID)\n        ? arr\n        : tagOwnerID(arrayClone(arr), ownerID);\n\n    copied.splice(idx, 1);\n    return copied;\n}\n\nexport function insert(ownerID, idx, val, arr) {\n    if (canMutate(arr, ownerID)) {\n        arr.splice(idx, 0, val);\n        return arr;\n    }\n\n    const newArrLen = arr.length + 1;\n    const newArr = new Array(newArrLen);\n\n    let i = 0;\n    for (; i < idx; i++) {\n        newArr[i] = arr[i];\n    }\n\n    newArr[i++] = val;\n\n    for (; i < newArrLen; i++) {\n        newArr[i] = arr[i - 1];\n    }\n\n    return newArr;\n}\n\nexport function set(ownerID, idx, val, arr) {\n    const copied = canMutate(arr, ownerID)\n        ? arr\n        : tagOwnerID(arrayClone(arr), ownerID);\n\n    copied[idx] = val;\n    return copied;\n}\n\nexport function fastMap(fn, arr) {\n    const copied = arrayClone(arr);\n    const len = arr.length;\n    for (let i = 0; i < len; i++) {\n        copied[i] = fn(arr[i], i);\n    }\n    return copied;\n}\n\nexport function splitAt(ownerID, idx, arr) {\n    const arrLen = arr.length;\n    const firstArrLen = idx;\n    const secondArrLen = arrLen - idx;\n    const secondArr = allocateArray(ownerID, secondArrLen);\n\n    const firstArr = allocateArray(ownerID, firstArrLen);\n\n    for (let i = 0; i < idx; i++) {\n        firstArr[i] = arr[i];\n    }\n\n    for (let i = idx; i < arrLen; i++) {\n        secondArr[i - idx] = arr[i];\n    }\n\n    return [firstArr, secondArr];\n}\n\nexport function unshift(ownerID, value, arr) {\n    return insert(ownerID, 0, value, arr);\n}\n\nexport const takeIdxAndSplit = (ownerID, idx, arr) => {\n    const cutoff = idx;\n    const a1len = cutoff;\n    const arr1 = slice(ownerID, 0, a1len, arr);\n    const arr2 = slice(ownerID, cutoff + 1, arr.length, arr);\n    return [arr1, arr[cutoff], arr2];\n};\n\nexport function last(arr) {\n    return arr[arr.length - 1];\n}\n\nexport function init(ownerID, arr) {\n    if (canMutate(arr, ownerID)) {\n        if (arr.length === 0) return arr;\n        arr.pop();\n        return arr;\n    }\n\n    if (arr.length <= 1) return allocateArray(ownerID);\n    return slice(ownerID, 0, arr.length - 1, arr);\n}\n\nexport function tail(ownerID, arr) {\n    if (canMutate(arr, ownerID)) {\n        arr.shift();\n        return arr;\n    }\n\n    if (arr.length <= 1) return tagOwnerID([], ownerID);\n    return slice(ownerID, 1, arr.length, arr);\n}\n\nexport function getEmptyIterator() {\n    const iterator = {\n        next: () => ({ done: true }),\n    };\n\n    iterator[ITERATOR_PROPNAME] = () => iterator;\n\n    return iterator;\n}\n\nexport const boundedChunk = (min, max, arr) => {\n    const arrLen = arr.length;\n    if (!arr.length) return [];\n    if (arr.length <= max) {\n        return [arr];\n    }\n\n    const avg = Math.ceil((min + max) / 2);\n    const parts = arrLen / avg;\n    const chunkCount = Math.ceil(parts);\n    const splitsize = (1 / chunkCount) * arrLen;\n    const chunks = new Array(chunkCount);\n    for (let i = 0; i < chunkCount; i++) {\n        chunks[i] = arr.slice(Math.ceil(i * splitsize), Math.ceil((i + 1) * splitsize));\n    }\n    return chunks;\n};\n\nexport function extend(target) {\n    const argsLen = arguments.length;\n    let source;\n    let keys;\n    let key;\n    let i;\n    let j;\n\n    for (j = 1; j < argsLen; j++) {\n        source = arguments[j];\n        keys = Object.keys(source);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\nexport function makeRef(value) {\n    return { value };\n}\n\nexport function setRef(ref) {\n    ref.value = true;\n}\n\nexport function isSet(ref) {\n    return !!ref.value;\n}\n\nexport function normalizeRangeSpec(spec) {\n    return {\n        from: spec.from,\n        to: spec.to,\n        fromInclusive: spec.hasOwnProperty('fromInclusive')\n            ? spec.fromInclusive\n            : true,\n        toInclusive: spec.hasOwnProperty('toInclusive')\n            ? spec.toInclusive\n            : true,\n    };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","import {\n    SHIFT_LEN,\n} from './constants';\nimport {\n    extend,\n} from './utils';\n\nconst MIN_PATH = 0;\nconst NUMBER_OF_UNSIGNED_BITS = 31;\n\nexport const LEVELS = Math.floor(NUMBER_OF_UNSIGNED_BITS / SHIFT_LEN);\n\n/**\n * Slices a range of bits from the binary\n * representation of a number.\n *\n * Example:\n *     num: decimal 376 = binary 101111000\n *     fromBit: 3\n *     toBit: 9\n *     Returns decimal 47 = binary 101111\n *\n * @param  {Number} fromBit - bit to start slicing from, inclusive\n * @param  {Number} toBit - bit to stop slicing at, exclusive\n * @param  {Number} num - number to slice\n * @return {Number} sliced number\n */\nexport const bitSlice = (fromBit, toBit, num) => {\n    // toBit exclusive. Mask is from bits 0..toBit - 1.\n    const mask = Math.pow(2, toBit) - 1;\n\n    return (num & mask) >>> fromBit;\n};\n\n/**\n * Gets the path value for a given level.\n *\n * Example:\n *     shiftLen: 6\n *     level: 1\n *     path:  decimal 16518336 = binary 111111 000000 110011 000000\n *     Returns: decimal 51 = 110011\n *\n * @param  {Number} shiftLen - the binary representation length of a single level\n * @param  {Number} level - the level to get a value from, starting at 0\n * @param  {Number} path - input path\n * @return {Number} value for `path` at level `level`\n */\nexport const pathGet = (shiftLen, level, path) =>\n    bitSlice(\n        shiftLen * level,\n        shiftLen * (level + 1),\n        path\n    );\n\n/**\n * Returns a new updated path where the value for a given level is\n * set to `newValue`. The current value of path at the given level must be 0.\n *\n * @param  {Number} shiftLen - the binary representation length of a single level\n * @param  {Number} level - the level to set the value to, starting at 0\n * @param  {Number} path\n * @param  {Number} newValue\n * @return {Number} an updated path\n */\nexport const pathSet = (shiftLen, level, path, newValue) =>\n    path | (newValue << (shiftLen * level));\n\nexport const clearBitRange = (fromBit, toBit, num) => {\n    const rangeLen = toBit - fromBit;\n    const mask = Math.pow(2, rangeLen) - 1;\n    return num & ~(mask << fromBit);\n};\n\n// Safe version of `pathSet` where the current value is cleared before\n// assigning a new value.\nexport const safePathSet = (shiftLen, level, path, newValue) => {\n    const cleared = clearBitRange(\n        shiftLen * level,\n        shiftLen * (level + 1),\n        path\n    );\n    return pathSet(shiftLen, level, cleared, newValue);\n};\n\nfunction Path(shiftLen, levels, path) {\n    this.shiftLen = shiftLen || SHIFT_LEN;\n    this.length = levels || LEVELS;\n    this._path = path || 0;\n}\n\nPath.EMPTY_PATH = new Path(SHIFT_LEN, LEVELS, MIN_PATH);\nPath.from = function from(arr) {\n    const levels = arr.length;\n\n    let path = 0;\n    for (let i = 0; i < levels; i++) {\n        path = pathSet(SHIFT_LEN, i, path, arr[i]);\n    }\n\n    return new Path(SHIFT_LEN, levels, path);\n};\n\nextend(Path.prototype, {\n    get(level) {\n        return pathGet(this.shiftLen, level, this._path);\n    },\n\n    equals(otherPath) {\n        return this._path === otherPath._path;\n    },\n\n    clearAfter(level) {\n        let currLevel = level + 1;\n        let newPath = this;\n        while (currLevel < this.length) {\n            newPath = newPath.set(currLevel, 0);\n            currLevel++;\n        }\n        return newPath;\n    },\n\n    toArray() {\n        const arr = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            arr[i] = this.get(i);\n        }\n        return arr;\n    },\n\n    compareTo(otherPath) {\n        const a = this._path;\n        const b = otherPath._path;\n        return a === b ? 0 : a < b ? - 1 : 1; // eslint-disable-line no-nested-ternary\n    },\n\n    increment(level) {\n        const newPath = this.set(level, this.get(level) + 1);\n        return newPath.clearAfter(level);\n    },\n\n    decrement(level) {\n        return this.set(level, this.get(level) - 1);\n    },\n\n    set(level, value) {\n        const newPath = safePathSet(this.shiftLen, level, this._path, value);\n        return new Path(this.shiftLen, this.length, newPath);\n    },\n});\n\nexport { Path };\nexport default Path;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/path.js\n **/"],"sourceRoot":""}